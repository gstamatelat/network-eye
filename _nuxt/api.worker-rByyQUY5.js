var hi=Object.defineProperty;var di=(_e,ye,xe)=>ye in _e?hi(_e,ye,{enumerable:!0,configurable:!0,writable:!0,value:xe}):_e[ye]=xe;var ge=(_e,ye,xe)=>di(_e,typeof ye!="symbol"?ye+"":ye,xe);(function(){"use strict";const _e=Symbol("Comlink.proxy"),ye=Symbol("Comlink.endpoint"),xe=Symbol("Comlink.releaseProxy"),Fe=Symbol("Comlink.thrown"),ot=i=>typeof i=="object"&&i!==null||typeof i=="function",Ut={canHandle:i=>ot(i)&&i[_e],serialize(i){const{port1:e,port2:t}=new MessageChannel;return We(i,e),[t,[t]]},deserialize(i){return i.start(),zt(i)}},Tt={canHandle:i=>ot(i)&&Fe in i,serialize({value:i}){let e;return i instanceof Error?e={isError:!0,value:{message:i.message,name:i.name,stack:i.stack}}:e={isError:!1,value:i},[e,[]]},deserialize(i){throw i.isError?Object.assign(new Error(i.value.message),i.value):i.value}},at=new Map([["proxy",Ut],["throw",Tt]]);function We(i,e=self){e.addEventListener("message",function t(r){if(!r||!r.data)return;const{id:n,type:s,path:o}=Object.assign({path:[]},r.data),a=(r.data.argumentList||[]).map($e);let u;try{const c=o.slice(0,-1).reduce((l,g)=>l[g],i),p=o.reduce((l,g)=>l[g],i);switch(s){case"GET":u=p;break;case"SET":c[o.slice(-1)[0]]=$e(r.data.value),u=!0;break;case"APPLY":u=p.apply(c,a);break;case"CONSTRUCT":{const l=new p(...a);u=Ft(l)}break;case"ENDPOINT":{const{port1:l,port2:g}=new MessageChannel;We(i,g),u=jt(l,[l])}break;case"RELEASE":u=void 0;break;default:return}}catch(c){u={value:c,[Fe]:0}}Promise.resolve(u).catch(c=>({value:c,[Fe]:0})).then(c=>{const[p,l]=Ke(c);e.postMessage(Object.assign(Object.assign({},p),{id:n}),l),s==="RELEASE"&&(e.removeEventListener("message",t),ut(e))})}),e.start&&e.start()}function Mt(i){return i.constructor.name==="MessagePort"}function ut(i){Mt(i)&&i.close()}function zt(i,e){return qe(i,[],e)}function Oe(i){if(i)throw new Error("Proxy has been released and is not useable")}function qe(i,e=[],t=function(){}){let r=!1;const n=new Proxy(t,{get(s,o){if(Oe(r),o===xe)return()=>Ae(i,{type:"RELEASE",path:e.map(a=>a.toString())}).then(()=>{ut(i),r=!0});if(o==="then"){if(e.length===0)return{then:()=>n};const a=Ae(i,{type:"GET",path:e.map(u=>u.toString())}).then($e);return a.then.bind(a)}return qe(i,[...e,o])},set(s,o,a){Oe(r);const[u,c]=Ke(a);return Ae(i,{type:"SET",path:[...e,o].map(p=>p.toString()),value:u},c).then($e)},apply(s,o,a){Oe(r);const u=e[e.length-1];if(u===ye)return Ae(i,{type:"ENDPOINT"}).then($e);if(u==="bind")return qe(i,e.slice(0,-1));const[c,p]=ht(a);return Ae(i,{type:"APPLY",path:e.map(l=>l.toString()),argumentList:c},p).then($e)},construct(s,o){Oe(r);const[a,u]=ht(o);return Ae(i,{type:"CONSTRUCT",path:e.map(c=>c.toString()),argumentList:a},u).then($e)}});return n}function Pt(i){return Array.prototype.concat.apply([],i)}function ht(i){const e=i.map(Ke);return[e.map(t=>t[0]),Pt(e.map(t=>t[1]))]}const dt=new WeakMap;function jt(i,e){return dt.set(i,e),i}function Ft(i){return Object.assign(i,{[_e]:!0})}function Ke(i){for(const[e,t]of at)if(t.canHandle(i)){const[r,n]=t.serialize(i);return[{type:"HANDLER",name:e,value:r},n]}return[{type:"RAW",value:i},dt.get(i)||[]]}function $e(i){switch(i.type){case"HANDLER":return at.get(i.name).deserialize(i.value);case"RAW":return i.value}}function Ae(i,e,t){return new Promise(r=>{const n=Wt();i.addEventListener("message",function s(o){!o.data||!o.data.id||o.data.id!==n||(i.removeEventListener("message",s),r(o.data))}),i.start&&i.start(),i.postMessage(Object.assign({id:n},e),t)})}function Wt(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}function Be(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var Ue={exports:{}},ct;function qt(){if(ct)return Ue.exports;ct=1;var i=typeof Reflect=="object"?Reflect:null,e=i&&typeof i.apply=="function"?i.apply:function(y,b,_){return Function.prototype.apply.call(y,b,_)},t;i&&typeof i.ownKeys=="function"?t=i.ownKeys:Object.getOwnPropertySymbols?t=function(y){return Object.getOwnPropertyNames(y).concat(Object.getOwnPropertySymbols(y))}:t=function(y){return Object.getOwnPropertyNames(y)};function r(m){console&&console.warn&&console.warn(m)}var n=Number.isNaN||function(y){return y!==y};function s(){s.init.call(this)}Ue.exports=s,Ue.exports.once=B,s.EventEmitter=s,s.prototype._events=void 0,s.prototype._eventsCount=0,s.prototype._maxListeners=void 0;var o=10;function a(m){if(typeof m!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof m)}Object.defineProperty(s,"defaultMaxListeners",{enumerable:!0,get:function(){return o},set:function(m){if(typeof m!="number"||m<0||n(m))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+m+".");o=m}}),s.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},s.prototype.setMaxListeners=function(y){if(typeof y!="number"||y<0||n(y))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+y+".");return this._maxListeners=y,this};function u(m){return m._maxListeners===void 0?s.defaultMaxListeners:m._maxListeners}s.prototype.getMaxListeners=function(){return u(this)},s.prototype.emit=function(y){for(var b=[],_=1;_<arguments.length;_++)b.push(arguments[_]);var h=y==="error",d=this._events;if(d!==void 0)h=h&&d.error===void 0;else if(!h)return!1;if(h){var f;if(b.length>0&&(f=b[0]),f instanceof Error)throw f;var E=new Error("Unhandled error."+(f?" ("+f.message+")":""));throw E.context=f,E}var k=d[y];if(k===void 0)return!1;if(typeof k=="function")e(k,this,b);else for(var C=k.length,R=U(k,C),_=0;_<C;++_)e(R[_],this,b);return!0};function c(m,y,b,_){var h,d,f;if(a(b),d=m._events,d===void 0?(d=m._events=Object.create(null),m._eventsCount=0):(d.newListener!==void 0&&(m.emit("newListener",y,b.listener?b.listener:b),d=m._events),f=d[y]),f===void 0)f=d[y]=b,++m._eventsCount;else if(typeof f=="function"?f=d[y]=_?[b,f]:[f,b]:_?f.unshift(b):f.push(b),h=u(m),h>0&&f.length>h&&!f.warned){f.warned=!0;var E=new Error("Possible EventEmitter memory leak detected. "+f.length+" "+String(y)+" listeners added. Use emitter.setMaxListeners() to increase limit");E.name="MaxListenersExceededWarning",E.emitter=m,E.type=y,E.count=f.length,r(E)}return m}s.prototype.addListener=function(y,b){return c(this,y,b,!1)},s.prototype.on=s.prototype.addListener,s.prototype.prependListener=function(y,b){return c(this,y,b,!0)};function p(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function l(m,y,b){var _={fired:!1,wrapFn:void 0,target:m,type:y,listener:b},h=p.bind(_);return h.listener=b,_.wrapFn=h,h}s.prototype.once=function(y,b){return a(b),this.on(y,l(this,y,b)),this},s.prototype.prependOnceListener=function(y,b){return a(b),this.prependListener(y,l(this,y,b)),this},s.prototype.removeListener=function(y,b){var _,h,d,f,E;if(a(b),h=this._events,h===void 0)return this;if(_=h[y],_===void 0)return this;if(_===b||_.listener===b)--this._eventsCount===0?this._events=Object.create(null):(delete h[y],h.removeListener&&this.emit("removeListener",y,_.listener||b));else if(typeof _!="function"){for(d=-1,f=_.length-1;f>=0;f--)if(_[f]===b||_[f].listener===b){E=_[f].listener,d=f;break}if(d<0)return this;d===0?_.shift():Y(_,d),_.length===1&&(h[y]=_[0]),h.removeListener!==void 0&&this.emit("removeListener",y,E||b)}return this},s.prototype.off=s.prototype.removeListener,s.prototype.removeAllListeners=function(y){var b,_,h;if(_=this._events,_===void 0)return this;if(_.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):_[y]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete _[y]),this;if(arguments.length===0){var d=Object.keys(_),f;for(h=0;h<d.length;++h)f=d[h],f!=="removeListener"&&this.removeAllListeners(f);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(b=_[y],typeof b=="function")this.removeListener(y,b);else if(b!==void 0)for(h=b.length-1;h>=0;h--)this.removeListener(y,b[h]);return this};function g(m,y,b){var _=m._events;if(_===void 0)return[];var h=_[y];return h===void 0?[]:typeof h=="function"?b?[h.listener||h]:[h]:b?P(h):U(h,h.length)}s.prototype.listeners=function(y){return g(this,y,!0)},s.prototype.rawListeners=function(y){return g(this,y,!1)},s.listenerCount=function(m,y){return typeof m.listenerCount=="function"?m.listenerCount(y):D.call(m,y)},s.prototype.listenerCount=D;function D(m){var y=this._events;if(y!==void 0){var b=y[m];if(typeof b=="function")return 1;if(b!==void 0)return b.length}return 0}s.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]};function U(m,y){for(var b=new Array(y),_=0;_<y;++_)b[_]=m[_];return b}function Y(m,y){for(;y+1<m.length;y++)m[y]=m[y+1];m.pop()}function P(m){for(var y=new Array(m.length),b=0;b<y.length;++b)y[b]=m[b].listener||m[b];return y}function B(m,y){return new Promise(function(b,_){function h(f){m.removeListener(y,d),_(f)}function d(){typeof m.removeListener=="function"&&m.removeListener("error",h),b([].slice.call(arguments))}ce(m,y,d,{once:!0}),y!=="error"&&ne(m,h,{once:!0})})}function ne(m,y,b){typeof m.on=="function"&&ce(m,"error",y,b)}function ce(m,y,b,_){if(typeof m.on=="function")_.once?m.once(y,b):m.on(y,b);else if(typeof m.addEventListener=="function")m.addEventListener(y,function h(d){_.once&&m.removeEventListener(y,h),b(d)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof m)}return Ue.exports}var Kt=qt(),He,ft;function Ye(){if(ft)return He;ft=1;function i(e){if(typeof e!="function")throw new Error("obliterator/iterator: expecting a function!");this.next=e}return typeof Symbol<"u"&&(i.prototype[Symbol.iterator]=function(){return this}),i.of=function(){var e=arguments,t=e.length,r=0;return new i(function(){return r>=t?{done:!0}:{done:!1,value:e[r++]}})},i.empty=function(){var e=new i(function(){return{done:!0}});return e},i.fromSequence=function(e){var t=0,r=e.length;return new i(function(){return t>=r?{done:!0}:{done:!1,value:e[t++]}})},i.is=function(e){return e instanceof i?!0:typeof e=="object"&&e!==null&&typeof e.next=="function"},He=i,He}var Bt=Ye(),se=Be(Bt),Te={},lt;function Ht(){return lt||(lt=1,Te.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer<"u",Te.SYMBOL_SUPPORT=typeof Symbol<"u"),Te}var Ve,pt;function gt(){if(pt)return Ve;pt=1;var i=Ye(),e=Ht(),t=e.ARRAY_BUFFER_SUPPORT,r=e.SYMBOL_SUPPORT;function n(s){return typeof s=="string"||Array.isArray(s)||t&&ArrayBuffer.isView(s)?i.fromSequence(s):typeof s!="object"||s===null?null:r&&typeof s[Symbol.iterator]=="function"?s[Symbol.iterator]():typeof s.next=="function"?s:null}return Ve=function(o){var a=n(o);if(!a)throw new Error("obliterator: target is not iterable nor a valid iterator.");return a},Ve}var Qe,yt;function Yt(){if(yt)return Qe;yt=1;var i=gt();return Qe=function(t,r){for(var n=arguments.length>1?r:1/0,s=n!==1/0?new Array(n):[],o,a=0,u=i(t);;){if(a===n)return s;if(o=u.next(),o.done)return a!==r&&(s.length=a),s;s[a++]=o.value}},Qe}var Vt=Yt(),wt=Be(Vt),Je,mt;function Qt(){if(mt)return Je;mt=1;var i=Ye(),e=gt();return Je=function(){var r=arguments,n=null,s=-1;return new i(function(){var a=null;do{if(n===null){if(s++,s>=r.length)return{done:!0};n=e(r[s])}if(a=n.next(),a.done===!0){n=null;continue}break}while(!0);return a})},Je}var Jt=Qt(),we=Be(Jt);function Zt(){const i=arguments[0];for(let e=1,t=arguments.length;e<t;e++)if(arguments[e])for(const r in arguments[e])i[r]=arguments[e][r];return i}let H=Zt;typeof Object.assign=="function"&&(H=Object.assign);function oe(i,e,t,r){const n=i._nodes.get(e);let s=null;return n&&(r==="mixed"?s=n.out&&n.out[t]||n.undirected&&n.undirected[t]:r==="directed"?s=n.out&&n.out[t]:s=n.undirected&&n.undirected[t]),s}function Xt(i){return i!==null&&typeof i=="object"&&typeof i.addUndirectedEdgeWithKey=="function"&&typeof i.dropNode=="function"}function J(i){return typeof i=="object"&&i!==null&&i.constructor===Object}function bt(i){let e;for(e in i)return!1;return!0}function ae(i,e,t){Object.defineProperty(i,e,{enumerable:!1,configurable:!1,writable:!0,value:t})}function de(i,e,t){const r={enumerable:!0,configurable:!0};typeof t=="function"?r.get=t:(r.value=t,r.writable=!1),Object.defineProperty(i,e,r)}function _t(i){return!(!J(i)||i.attributes&&!Array.isArray(i.attributes))}function er(){let i=Math.floor(Math.random()*256)&255;return()=>i++}class Ze extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}class v extends Ze{constructor(e){super(e),this.name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,v.prototype.constructor)}}class w extends Ze{constructor(e){super(e),this.name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,w.prototype.constructor)}}class A extends Ze{constructor(e){super(e),this.name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,A.prototype.constructor)}}function vt(i,e){this.key=i,this.attributes=e,this.clear()}vt.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.in={},this.out={},this.undirected={}};function Et(i,e){this.key=i,this.attributes=e,this.clear()}Et.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.in={},this.out={}};function kt(i,e){this.key=i,this.attributes=e,this.clear()}kt.prototype.clear=function(){this.undirectedDegree=0,this.undirected={}};function Ge(i,e,t,r,n){this.key=e,this.attributes=n,this.undirected=i,this.source=t,this.target=r}Ge.prototype.attach=function(){let i="out",e="in";this.undirected&&(i=e="undirected");const t=this.source.key,r=this.target.key;this.source[i][r]=this,!(this.undirected&&t===r)&&(this.target[e][t]=this)},Ge.prototype.attachMulti=function(){let i="out",e="in";const t=this.source.key,r=this.target.key;this.undirected&&(i=e="undirected");const n=this.source[i],s=n[r];if(typeof s>"u"){n[r]=this,this.undirected&&t===r||(this.target[e][t]=this);return}s.previous=this,this.next=s,n[r]=this,this.target[e][t]=this},Ge.prototype.detach=function(){const i=this.source.key,e=this.target.key;let t="out",r="in";this.undirected&&(t=r="undirected"),delete this.source[t][e],delete this.target[r][i]},Ge.prototype.detachMulti=function(){const i=this.source.key,e=this.target.key;let t="out",r="in";this.undirected&&(t=r="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[t][e],delete this.target[r][i]):(this.next.previous=void 0,this.source[t][e]=this.next,this.target[r][i]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};const $t=0,xt=1,tr=2,At=3;function me(i,e,t,r,n,s,o){let a,u,c,p;if(r=""+r,t===$t){if(a=i._nodes.get(r),!a)throw new w(`Graph.${e}: could not find the "${r}" node in the graph.`);c=n,p=s}else if(t===At){if(n=""+n,u=i._edges.get(n),!u)throw new w(`Graph.${e}: could not find the "${n}" edge in the graph.`);const l=u.source.key,g=u.target.key;if(r===l)a=u.target;else if(r===g)a=u.source;else throw new w(`Graph.${e}: the "${r}" node is not attached to the "${n}" edge (${l}, ${g}).`);c=s,p=o}else{if(u=i._edges.get(r),!u)throw new w(`Graph.${e}: could not find the "${r}" edge in the graph.`);t===xt?a=u.source:a=u.target,c=n,p=s}return[a,c,p]}function rr(i,e,t){i.prototype[e]=function(r,n,s){const[o,a]=me(this,e,t,r,n,s);return o.attributes[a]}}function ir(i,e,t){i.prototype[e]=function(r,n){const[s]=me(this,e,t,r,n);return s.attributes}}function nr(i,e,t){i.prototype[e]=function(r,n,s){const[o,a]=me(this,e,t,r,n,s);return o.attributes.hasOwnProperty(a)}}function sr(i,e,t){i.prototype[e]=function(r,n,s,o){const[a,u,c]=me(this,e,t,r,n,s,o);return a.attributes[u]=c,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:u}),this}}function or(i,e,t){i.prototype[e]=function(r,n,s,o){const[a,u,c]=me(this,e,t,r,n,s,o);if(typeof c!="function")throw new v(`Graph.${e}: updater should be a function.`);const p=a.attributes,l=c(p[u]);return p[u]=l,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:u}),this}}function ar(i,e,t){i.prototype[e]=function(r,n,s){const[o,a]=me(this,e,t,r,n,s);return delete o.attributes[a],this.emit("nodeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:a}),this}}function ur(i,e,t){i.prototype[e]=function(r,n,s){const[o,a]=me(this,e,t,r,n,s);if(!J(a))throw new v(`Graph.${e}: provided attributes are not a plain object.`);return o.attributes=a,this.emit("nodeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}function hr(i,e,t){i.prototype[e]=function(r,n,s){const[o,a]=me(this,e,t,r,n,s);if(!J(a))throw new v(`Graph.${e}: provided attributes are not a plain object.`);return H(o.attributes,a),this.emit("nodeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:a}),this}}function dr(i,e,t){i.prototype[e]=function(r,n,s){const[o,a]=me(this,e,t,r,n,s);if(typeof a!="function")throw new v(`Graph.${e}: provided updater is not a function.`);return o.attributes=a(o.attributes),this.emit("nodeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}const cr=[{name:i=>`get${i}Attribute`,attacher:rr},{name:i=>`get${i}Attributes`,attacher:ir},{name:i=>`has${i}Attribute`,attacher:nr},{name:i=>`set${i}Attribute`,attacher:sr},{name:i=>`update${i}Attribute`,attacher:or},{name:i=>`remove${i}Attribute`,attacher:ar},{name:i=>`replace${i}Attributes`,attacher:ur},{name:i=>`merge${i}Attributes`,attacher:hr},{name:i=>`update${i}Attributes`,attacher:dr}];function fr(i){cr.forEach(function({name:e,attacher:t}){t(i,e("Node"),$t),t(i,e("Source"),xt),t(i,e("Target"),tr),t(i,e("Opposite"),At)})}function lr(i,e,t){i.prototype[e]=function(r,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new A(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new A(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+r,a=""+n;if(n=arguments[2],s=oe(this,o,a,t),!s)throw new w(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new A(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new w(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return s.attributes[n]}}function pr(i,e,t){i.prototype[e]=function(r){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new A(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new A(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,o=""+arguments[1];if(n=oe(this,s,o,t),!n)throw new w(`Graph.${e}: could not find an edge for the given path ("${s}" - "${o}").`)}else{if(t!=="mixed")throw new A(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new w(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return n.attributes}}function gr(i,e,t){i.prototype[e]=function(r,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new A(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new A(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+r,a=""+n;if(n=arguments[2],s=oe(this,o,a,t),!s)throw new w(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new A(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new w(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return s.attributes.hasOwnProperty(n)}}function yr(i,e,t){i.prototype[e]=function(r,n,s){let o;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new A(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new A(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+r,u=""+n;if(n=arguments[2],s=arguments[3],o=oe(this,a,u,t),!o)throw new w(`Graph.${e}: could not find an edge for the given path ("${a}" - "${u}").`)}else{if(t!=="mixed")throw new A(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,o=this._edges.get(r),!o)throw new w(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return o.attributes[n]=s,this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:n}),this}}function wr(i,e,t){i.prototype[e]=function(r,n,s){let o;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new A(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new A(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+r,u=""+n;if(n=arguments[2],s=arguments[3],o=oe(this,a,u,t),!o)throw new w(`Graph.${e}: could not find an edge for the given path ("${a}" - "${u}").`)}else{if(t!=="mixed")throw new A(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,o=this._edges.get(r),!o)throw new w(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(typeof s!="function")throw new v(`Graph.${e}: updater should be a function.`);return o.attributes[n]=s(o.attributes[n]),this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:n}),this}}function mr(i,e,t){i.prototype[e]=function(r,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new A(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new A(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+r,a=""+n;if(n=arguments[2],s=oe(this,o,a,t),!s)throw new w(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new A(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new w(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return delete s.attributes[n],this.emit("edgeAttributesUpdated",{key:s.key,type:"remove",attributes:s.attributes,name:n}),this}}function br(i,e,t){i.prototype[e]=function(r,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new A(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new A(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+r,a=""+n;if(n=arguments[2],s=oe(this,o,a,t),!s)throw new w(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new A(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new w(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(!J(n))throw new v(`Graph.${e}: provided attributes are not a plain object.`);return s.attributes=n,this.emit("edgeAttributesUpdated",{key:s.key,type:"replace",attributes:s.attributes}),this}}function _r(i,e,t){i.prototype[e]=function(r,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new A(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new A(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+r,a=""+n;if(n=arguments[2],s=oe(this,o,a,t),!s)throw new w(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new A(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new w(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(!J(n))throw new v(`Graph.${e}: provided attributes are not a plain object.`);return H(s.attributes,n),this.emit("edgeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:n}),this}}function vr(i,e,t){i.prototype[e]=function(r,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new A(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new A(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+r,a=""+n;if(n=arguments[2],s=oe(this,o,a,t),!s)throw new w(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new A(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new w(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(typeof n!="function")throw new v(`Graph.${e}: provided updater is not a function.`);return s.attributes=n(s.attributes),this.emit("edgeAttributesUpdated",{key:s.key,type:"update",attributes:s.attributes}),this}}const Er=[{name:i=>`get${i}Attribute`,attacher:lr},{name:i=>`get${i}Attributes`,attacher:pr},{name:i=>`has${i}Attribute`,attacher:gr},{name:i=>`set${i}Attribute`,attacher:yr},{name:i=>`update${i}Attribute`,attacher:wr},{name:i=>`remove${i}Attribute`,attacher:mr},{name:i=>`replace${i}Attributes`,attacher:br},{name:i=>`merge${i}Attributes`,attacher:_r},{name:i=>`update${i}Attributes`,attacher:vr}];function kr(i){Er.forEach(function({name:e,attacher:t}){t(i,e("Edge"),"mixed"),t(i,e("DirectedEdge"),"directed"),t(i,e("UndirectedEdge"),"undirected")})}const $r=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function xr(i,e,t,r){let n=!1;for(const s in e){if(s===r)continue;const o=e[s];if(n=t(o.key,o.attributes,o.source.key,o.target.key,o.source.attributes,o.target.attributes,o.undirected),i&&n)return o.key}}function Ar(i,e,t,r){let n,s,o,a=!1;for(const u in e)if(u!==r){n=e[u];do{if(s=n.source,o=n.target,a=t(n.key,n.attributes,s.key,o.key,s.attributes,o.attributes,n.undirected),i&&a)return n.key;n=n.next}while(n!==void 0)}}function Xe(i,e){const t=Object.keys(i),r=t.length;let n,s=0;return new se(function(){do if(n)n=n.next;else{if(s>=r)return{done:!0};const a=t[s++];if(a===e){n=void 0;continue}n=i[a]}while(!n);return{done:!1,value:{edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected}}})}function Gr(i,e,t,r){const n=e[t];if(!n)return;const s=n.source,o=n.target;if(r(n.key,n.attributes,s.key,o.key,s.attributes,o.attributes,n.undirected)&&i)return n.key}function Dr(i,e,t,r){let n=e[t];if(!n)return;let s=!1;do{if(s=r(n.key,n.attributes,n.source.key,n.target.key,n.source.attributes,n.target.attributes,n.undirected),i&&s)return n.key;n=n.next}while(n!==void 0)}function et(i,e){let t=i[e];return t.next!==void 0?new se(function(){if(!t)return{done:!0};const r={edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected};return t=t.next,{done:!1,value:r}}):se.of({edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected})}function Sr(i,e){if(i.size===0)return[];if(e==="mixed"||e===i.type)return typeof Array.from=="function"?Array.from(i._edges.keys()):wt(i._edges.keys(),i._edges.size);const t=e==="undirected"?i.undirectedSize:i.directedSize,r=new Array(t),n=e==="undirected",s=i._edges.values();let o=0,a,u;for(;a=s.next(),a.done!==!0;)u=a.value,u.undirected===n&&(r[o++]=u.key);return r}function Gt(i,e,t,r){if(e.size===0)return;const n=t!=="mixed"&&t!==e.type,s=t==="undirected";let o,a,u=!1;const c=e._edges.values();for(;o=c.next(),o.done!==!0;){if(a=o.value,n&&a.undirected!==s)continue;const{key:p,attributes:l,source:g,target:D}=a;if(u=r(p,l,g.key,D.key,g.attributes,D.attributes,a.undirected),i&&u)return p}}function Cr(i,e){if(i.size===0)return se.empty();const t=e!=="mixed"&&e!==i.type,r=e==="undirected",n=i._edges.values();return new se(function(){let o,a;for(;;){if(o=n.next(),o.done)return o;if(a=o.value,!(t&&a.undirected!==r))break}return{value:{edge:a.key,attributes:a.attributes,source:a.source.key,target:a.target.key,sourceAttributes:a.source.attributes,targetAttributes:a.target.attributes,undirected:a.undirected},done:!1}})}function tt(i,e,t,r,n,s){const o=e?Ar:xr;let a;if(t!=="undirected"&&(r!=="out"&&(a=o(i,n.in,s),i&&a)||r!=="in"&&(a=o(i,n.out,s,r?void 0:n.key),i&&a))||t!=="directed"&&(a=o(i,n.undirected,s),i&&a))return a}function Lr(i,e,t,r){const n=[];return tt(!1,i,e,t,r,function(s){n.push(s)}),n}function Nr(i,e,t){let r=se.empty();return i!=="undirected"&&(e!=="out"&&typeof t.in<"u"&&(r=we(r,Xe(t.in))),e!=="in"&&typeof t.out<"u"&&(r=we(r,Xe(t.out,e?void 0:t.key)))),i!=="directed"&&typeof t.undirected<"u"&&(r=we(r,Xe(t.undirected))),r}function rt(i,e,t,r,n,s,o){const a=t?Dr:Gr;let u;if(e!=="undirected"&&(typeof n.in<"u"&&r!=="out"&&(u=a(i,n.in,s,o),i&&u)||typeof n.out<"u"&&r!=="in"&&(r||n.key!==s)&&(u=a(i,n.out,s,o),i&&u))||e!=="directed"&&typeof n.undirected<"u"&&(u=a(i,n.undirected,s,o),i&&u))return u}function Rr(i,e,t,r,n){const s=[];return rt(!1,i,e,t,r,n,function(o){s.push(o)}),s}function Ir(i,e,t,r){let n=se.empty();return i!=="undirected"&&(typeof t.in<"u"&&e!=="out"&&r in t.in&&(n=we(n,et(t.in,r))),typeof t.out<"u"&&e!=="in"&&r in t.out&&(e||t.key!==r)&&(n=we(n,et(t.out,r)))),i!=="directed"&&typeof t.undirected<"u"&&r in t.undirected&&(n=we(n,et(t.undirected,r))),n}function Or(i,e){const{name:t,type:r,direction:n}=e;i.prototype[t]=function(s,o){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return[];if(!arguments.length)return Sr(this,r);if(arguments.length===1){s=""+s;const a=this._nodes.get(s);if(typeof a>"u")throw new w(`Graph.${t}: could not find the "${s}" node in the graph.`);return Lr(this.multi,r==="mixed"?this.type:r,n,a)}if(arguments.length===2){s=""+s,o=""+o;const a=this._nodes.get(s);if(!a)throw new w(`Graph.${t}:  could not find the "${s}" source node in the graph.`);if(!this._nodes.has(o))throw new w(`Graph.${t}:  could not find the "${o}" target node in the graph.`);return Rr(r,this.multi,n,a,o)}throw new v(`Graph.${t}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Ur(i,e){const{name:t,type:r,direction:n}=e,s="forEach"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(c,p,l){if(!(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)){if(arguments.length===1)return l=c,Gt(!1,this,r,l);if(arguments.length===2){c=""+c,l=p;const g=this._nodes.get(c);if(typeof g>"u")throw new w(`Graph.${s}: could not find the "${c}" node in the graph.`);return tt(!1,this.multi,r==="mixed"?this.type:r,n,g,l)}if(arguments.length===3){c=""+c,p=""+p;const g=this._nodes.get(c);if(!g)throw new w(`Graph.${s}:  could not find the "${c}" source node in the graph.`);if(!this._nodes.has(p))throw new w(`Graph.${s}:  could not find the "${p}" target node in the graph.`);return rt(!1,r,this.multi,n,g,p,l)}throw new v(`Graph.${s}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const o="map"+t[0].toUpperCase()+t.slice(1);i.prototype[o]=function(){const c=Array.prototype.slice.call(arguments),p=c.pop();let l;if(c.length===0){let g=0;r!=="directed"&&(g+=this.undirectedSize),r!=="undirected"&&(g+=this.directedSize),l=new Array(g);let D=0;c.push((U,Y,P,B,ne,ce,m)=>{l[D++]=p(U,Y,P,B,ne,ce,m)})}else l=[],c.push((g,D,U,Y,P,B,ne)=>{l.push(p(g,D,U,Y,P,B,ne))});return this[s].apply(this,c),l};const a="filter"+t[0].toUpperCase()+t.slice(1);i.prototype[a]=function(){const c=Array.prototype.slice.call(arguments),p=c.pop(),l=[];return c.push((g,D,U,Y,P,B,ne)=>{p(g,D,U,Y,P,B,ne)&&l.push(g)}),this[s].apply(this,c),l};const u="reduce"+t[0].toUpperCase()+t.slice(1);i.prototype[u]=function(){let c=Array.prototype.slice.call(arguments);if(c.length<2||c.length>4)throw new v(`Graph.${u}: invalid number of arguments (expecting 2, 3 or 4 and got ${c.length}).`);if(typeof c[c.length-1]=="function"&&typeof c[c.length-2]!="function")throw new v(`Graph.${u}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let p,l;c.length===2?(p=c[0],l=c[1],c=[]):c.length===3?(p=c[1],l=c[2],c=[c[0]]):c.length===4&&(p=c[2],l=c[3],c=[c[0],c[1]]);let g=l;return c.push((D,U,Y,P,B,ne,ce)=>{g=p(g,D,U,Y,P,B,ne,ce)}),this[s].apply(this,c),g}}function Tr(i,e){const{name:t,type:r,direction:n}=e,s="find"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(u,c,p){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return!1;if(arguments.length===1)return p=u,Gt(!0,this,r,p);if(arguments.length===2){u=""+u,p=c;const l=this._nodes.get(u);if(typeof l>"u")throw new w(`Graph.${s}: could not find the "${u}" node in the graph.`);return tt(!0,this.multi,r==="mixed"?this.type:r,n,l,p)}if(arguments.length===3){u=""+u,c=""+c;const l=this._nodes.get(u);if(!l)throw new w(`Graph.${s}:  could not find the "${u}" source node in the graph.`);if(!this._nodes.has(c))throw new w(`Graph.${s}:  could not find the "${c}" target node in the graph.`);return rt(!0,r,this.multi,n,l,c,p)}throw new v(`Graph.${s}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const o="some"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[o]=function(){const u=Array.prototype.slice.call(arguments),c=u.pop();return u.push((l,g,D,U,Y,P,B)=>c(l,g,D,U,Y,P,B)),!!this[s].apply(this,u)};const a="every"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[a]=function(){const u=Array.prototype.slice.call(arguments),c=u.pop();return u.push((l,g,D,U,Y,P,B)=>!c(l,g,D,U,Y,P,B)),!this[s].apply(this,u)}}function Mr(i,e){const{name:t,type:r,direction:n}=e,s=t.slice(0,-1)+"Entries";i.prototype[s]=function(o,a){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return se.empty();if(!arguments.length)return Cr(this,r);if(arguments.length===1){o=""+o;const u=this._nodes.get(o);if(!u)throw new w(`Graph.${s}: could not find the "${o}" node in the graph.`);return Nr(r,n,u)}if(arguments.length===2){o=""+o,a=""+a;const u=this._nodes.get(o);if(!u)throw new w(`Graph.${s}:  could not find the "${o}" source node in the graph.`);if(!this._nodes.has(a))throw new w(`Graph.${s}:  could not find the "${a}" target node in the graph.`);return Ir(r,n,u,a)}throw new v(`Graph.${s}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function zr(i){$r.forEach(e=>{Or(i,e),Ur(i,e),Tr(i,e),Mr(i,e)})}const Pr=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function Me(){this.A=null,this.B=null}Me.prototype.wrap=function(i){this.A===null?this.A=i:this.B===null&&(this.B=i)},Me.prototype.has=function(i){return this.A!==null&&i in this.A||this.B!==null&&i in this.B};function Le(i,e,t,r,n){for(const s in r){const o=r[s],a=o.source,u=o.target,c=a===t?u:a;if(e&&e.has(c.key))continue;const p=n(c.key,c.attributes);if(i&&p)return c.key}}function it(i,e,t,r,n){if(e!=="mixed"){if(e==="undirected")return Le(i,null,r,r.undirected,n);if(typeof t=="string")return Le(i,null,r,r[t],n)}const s=new Me;let o;if(e!=="undirected"){if(t!=="out"){if(o=Le(i,null,r,r.in,n),i&&o)return o;s.wrap(r.in)}if(t!=="in"){if(o=Le(i,s,r,r.out,n),i&&o)return o;s.wrap(r.out)}}if(e!=="directed"&&(o=Le(i,s,r,r.undirected,n),i&&o))return o}function jr(i,e,t){if(i!=="mixed"){if(i==="undirected")return Object.keys(t.undirected);if(typeof e=="string")return Object.keys(t[e])}const r=[];return it(!1,i,e,t,function(n){r.push(n)}),r}function Ne(i,e,t){const r=Object.keys(t),n=r.length;let s=0;return new se(function(){let a=null;do{if(s>=n)return i&&i.wrap(t),{done:!0};const u=t[r[s++]],c=u.source,p=u.target;if(a=c===e?p:c,i&&i.has(a.key)){a=null;continue}}while(a===null);return{done:!1,value:{neighbor:a.key,attributes:a.attributes}}})}function Fr(i,e,t){if(i!=="mixed"){if(i==="undirected")return Ne(null,t,t.undirected);if(typeof e=="string")return Ne(null,t,t[e])}let r=se.empty();const n=new Me;return i!=="undirected"&&(e!=="out"&&(r=we(r,Ne(n,t,t.in))),e!=="in"&&(r=we(r,Ne(n,t,t.out)))),i!=="directed"&&(r=we(r,Ne(n,t,t.undirected))),r}function Wr(i,e){const{name:t,type:r,direction:n}=e;i.prototype[t]=function(s){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return[];s=""+s;const o=this._nodes.get(s);if(typeof o>"u")throw new w(`Graph.${t}: could not find the "${s}" node in the graph.`);return jr(r==="mixed"?this.type:r,n,o)}}function qr(i,e){const{name:t,type:r,direction:n}=e,s="forEach"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(c,p){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return;c=""+c;const l=this._nodes.get(c);if(typeof l>"u")throw new w(`Graph.${s}: could not find the "${c}" node in the graph.`);it(!1,r==="mixed"?this.type:r,n,l,p)};const o="map"+t[0].toUpperCase()+t.slice(1);i.prototype[o]=function(c,p){const l=[];return this[s](c,(g,D)=>{l.push(p(g,D))}),l};const a="filter"+t[0].toUpperCase()+t.slice(1);i.prototype[a]=function(c,p){const l=[];return this[s](c,(g,D)=>{p(g,D)&&l.push(g)}),l};const u="reduce"+t[0].toUpperCase()+t.slice(1);i.prototype[u]=function(c,p,l){if(arguments.length<3)throw new v(`Graph.${u}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let g=l;return this[s](c,(D,U)=>{g=p(g,D,U)}),g}}function Kr(i,e){const{name:t,type:r,direction:n}=e,s=t[0].toUpperCase()+t.slice(1,-1),o="find"+s;i.prototype[o]=function(c,p){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return;c=""+c;const l=this._nodes.get(c);if(typeof l>"u")throw new w(`Graph.${o}: could not find the "${c}" node in the graph.`);return it(!0,r==="mixed"?this.type:r,n,l,p)};const a="some"+s;i.prototype[a]=function(c,p){return!!this[o](c,p)};const u="every"+s;i.prototype[u]=function(c,p){return!this[o](c,(g,D)=>!p(g,D))}}function Br(i,e){const{name:t,type:r,direction:n}=e,s=t.slice(0,-1)+"Entries";i.prototype[s]=function(o){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return se.empty();o=""+o;const a=this._nodes.get(o);if(typeof a>"u")throw new w(`Graph.${s}: could not find the "${o}" node in the graph.`);return Fr(r==="mixed"?this.type:r,n,a)}}function Hr(i){Pr.forEach(e=>{Wr(i,e),qr(i,e),Kr(i,e),Br(i,e)})}function ze(i,e,t,r,n){const s=r._nodes.values(),o=r.type;let a,u,c,p,l,g;for(;a=s.next(),a.done!==!0;){let D=!1;if(u=a.value,o!=="undirected"){p=u.out;for(c in p){l=p[c];do g=l.target,D=!0,n(u.key,g.key,u.attributes,g.attributes,l.key,l.attributes,l.undirected),l=l.next;while(l)}}if(o!=="directed"){p=u.undirected;for(c in p)if(!(e&&u.key>c)){l=p[c];do g=l.target,g.key!==c&&(g=l.source),D=!0,n(u.key,g.key,u.attributes,g.attributes,l.key,l.attributes,l.undirected),l=l.next;while(l)}}t&&!D&&n(u.key,null,u.attributes,null,null,null,null)}}function Yr(i,e){const t={key:i};return bt(e.attributes)||(t.attributes=H({},e.attributes)),t}function Vr(i,e){const t={key:i,source:e.source.key,target:e.target.key};return bt(e.attributes)||(t.attributes=H({},e.attributes)),e.undirected&&(t.undirected=!0),t}function Qr(i){if(!J(i))throw new v('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in i))throw new v("Graph.import: serialized node is missing its key.");if("attributes"in i&&(!J(i.attributes)||i.attributes===null))throw new v("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function Jr(i){if(!J(i))throw new v('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in i))throw new v("Graph.import: serialized edge is missing its source.");if(!("target"in i))throw new v("Graph.import: serialized edge is missing its target.");if("attributes"in i&&(!J(i.attributes)||i.attributes===null))throw new v("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in i&&typeof i.undirected!="boolean")throw new v("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}const Zr=er(),Xr=new Set(["directed","undirected","mixed"]),Dt=new Set(["domain","_events","_eventsCount","_maxListeners"]),ei=[{name:i=>`${i}Edge`,generateKey:!0},{name:i=>`${i}DirectedEdge`,generateKey:!0,type:"directed"},{name:i=>`${i}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:i=>`${i}EdgeWithKey`},{name:i=>`${i}DirectedEdgeWithKey`,type:"directed"},{name:i=>`${i}UndirectedEdgeWithKey`,type:"undirected"}],ti={allowSelfLoops:!0,multi:!1,type:"mixed"};function ri(i,e,t){if(t&&!J(t))throw new v(`Graph.addNode: invalid attributes. Expecting an object but got "${t}"`);if(e=""+e,t=t||{},i._nodes.has(e))throw new A(`Graph.addNode: the "${e}" node already exist in the graph.`);const r=new i.NodeDataClass(e,t);return i._nodes.set(e,r),i.emit("nodeAdded",{key:e,attributes:t}),r}function St(i,e,t){const r=new i.NodeDataClass(e,t);return i._nodes.set(e,r),i.emit("nodeAdded",{key:e,attributes:t}),r}function Ct(i,e,t,r,n,s,o,a){if(!r&&i.type==="undirected")throw new A(`Graph.${e}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(r&&i.type==="directed")throw new A(`Graph.${e}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(a&&!J(a))throw new v(`Graph.${e}: invalid attributes. Expecting an object but got "${a}"`);if(s=""+s,o=""+o,a=a||{},!i.allowSelfLoops&&s===o)throw new A(`Graph.${e}: source & target are the same ("${s}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const u=i._nodes.get(s),c=i._nodes.get(o);if(!u)throw new w(`Graph.${e}: source node "${s}" not found.`);if(!c)throw new w(`Graph.${e}: target node "${o}" not found.`);const p={key:null,undirected:r,source:s,target:o,attributes:a};if(t)n=i._edgeKeyGenerator();else if(n=""+n,i._edges.has(n))throw new A(`Graph.${e}: the "${n}" edge already exists in the graph.`);if(!i.multi&&(r?typeof u.undirected[o]<"u":typeof u.out[o]<"u"))throw new A(`Graph.${e}: an edge linking "${s}" to "${o}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const l=new Ge(r,n,u,c,a);i._edges.set(n,l);const g=s===o;return r?(u.undirectedDegree++,c.undirectedDegree++,g&&i._undirectedSelfLoopCount++):(u.outDegree++,c.inDegree++,g&&i._directedSelfLoopCount++),i.multi?l.attachMulti():l.attach(),r?i._undirectedSize++:i._directedSize++,p.key=n,i.emit("edgeAdded",p),n}function ii(i,e,t,r,n,s,o,a,u){if(!r&&i.type==="undirected")throw new A(`Graph.${e}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(r&&i.type==="directed")throw new A(`Graph.${e}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(a){if(u){if(typeof a!="function")throw new v(`Graph.${e}: invalid updater function. Expecting a function but got "${a}"`)}else if(!J(a))throw new v(`Graph.${e}: invalid attributes. Expecting an object but got "${a}"`)}s=""+s,o=""+o;let c;if(u&&(c=a,a=void 0),!i.allowSelfLoops&&s===o)throw new A(`Graph.${e}: source & target are the same ("${s}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let p=i._nodes.get(s),l=i._nodes.get(o),g,D;if(!t&&(g=i._edges.get(n),g)){if((g.source.key!==s||g.target.key!==o)&&(!r||g.source.key!==o||g.target.key!==s))throw new A(`Graph.${e}: inconsistency detected when attempting to merge the "${n}" edge with "${s}" source & "${o}" target vs. ("${g.source.key}", "${g.target.key}").`);D=g}if(!D&&!i.multi&&p&&(D=r?p.undirected[o]:p.out[o]),D){const ne=[D.key,!1,!1,!1];if(u?!c:!a)return ne;if(u){const ce=D.attributes;D.attributes=c(ce),i.emit("edgeAttributesUpdated",{type:"replace",key:D.key,attributes:D.attributes})}else H(D.attributes,a),i.emit("edgeAttributesUpdated",{type:"merge",key:D.key,attributes:D.attributes,data:a});return ne}a=a||{},u&&c&&(a=c(a));const U={key:null,undirected:r,source:s,target:o,attributes:a};if(t)n=i._edgeKeyGenerator();else if(n=""+n,i._edges.has(n))throw new A(`Graph.${e}: the "${n}" edge already exists in the graph.`);let Y=!1,P=!1;p||(p=St(i,s,{}),Y=!0,s===o&&(l=p,P=!0)),l||(l=St(i,o,{}),P=!0),g=new Ge(r,n,p,l,a),i._edges.set(n,g);const B=s===o;return r?(p.undirectedDegree++,l.undirectedDegree++,B&&i._undirectedSelfLoopCount++):(p.outDegree++,l.inDegree++,B&&i._directedSelfLoopCount++),i.multi?g.attachMulti():g.attach(),r?i._undirectedSize++:i._directedSize++,U.key=n,i.emit("edgeAdded",U),[n,!0,Y,P]}function De(i,e){i._edges.delete(e.key);const{source:t,target:r,attributes:n}=e,s=e.undirected,o=t===r;s?(t.undirectedDegree--,r.undirectedDegree--,o&&i._undirectedSelfLoopCount--):(t.outDegree--,r.inDegree--,o&&i._directedSelfLoopCount--),i.multi?e.detachMulti():e.detach(),s?i._undirectedSize--:i._directedSize--,i.emit("edgeDropped",{key:e.key,attributes:n,source:t.key,target:r.key,undirected:s})}class T extends Kt.EventEmitter{constructor(e){if(super(),e=H({},ti,e),typeof e.multi!="boolean")throw new v(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!Xr.has(e.type))throw new v(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if(typeof e.allowSelfLoops!="boolean")throw new v(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);const t=e.type==="mixed"?vt:e.type==="directed"?Et:kt;ae(this,"NodeDataClass",t);const r="geid_"+Zr()+"_";let n=0;const s=()=>{let o;do o=r+n++;while(this._edges.has(o));return o};ae(this,"_attributes",{}),ae(this,"_nodes",new Map),ae(this,"_edges",new Map),ae(this,"_directedSize",0),ae(this,"_undirectedSize",0),ae(this,"_directedSelfLoopCount",0),ae(this,"_undirectedSelfLoopCount",0),ae(this,"_edgeKeyGenerator",s),ae(this,"_options",e),Dt.forEach(o=>ae(this,o,this[o])),de(this,"order",()=>this._nodes.size),de(this,"size",()=>this._edges.size),de(this,"directedSize",()=>this._directedSize),de(this,"undirectedSize",()=>this._undirectedSize),de(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),de(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),de(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),de(this,"multi",this._options.multi),de(this,"type",this._options.type),de(this,"allowSelfLoops",this._options.allowSelfLoops),de(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if(this.type==="undirected")return!1;if(arguments.length===1){const r=""+e,n=this._edges.get(r);return!!n&&!n.undirected}else if(arguments.length===2){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)return!1;const n=r.out[t];return n?this.multi?!!n.size:!0:!1}throw new v(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(e,t){if(this.type==="directed")return!1;if(arguments.length===1){const r=""+e,n=this._edges.get(r);return!!n&&n.undirected}else if(arguments.length===2){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)return!1;const n=r.undirected[t];return n?this.multi?!!n.size:!0:!1}throw new v(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(e,t){if(arguments.length===1){const r=""+e;return this._edges.has(r)}else if(arguments.length===2){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)return!1;let n=typeof r.out<"u"&&r.out[t];return n||(n=typeof r.undirected<"u"&&r.undirected[t]),n?this.multi?!!n.size:!0:!1}throw new v(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(e,t){if(this.type==="undirected")return;if(e=""+e,t=""+t,this.multi)throw new A("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const r=this._nodes.get(e);if(!r)throw new w(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new w(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);const n=r.out&&r.out[t]||void 0;if(n)return n.key}undirectedEdge(e,t){if(this.type==="directed")return;if(e=""+e,t=""+t,this.multi)throw new A("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const r=this._nodes.get(e);if(!r)throw new w(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new w(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);const n=r.undirected&&r.undirected[t]||void 0;if(n)return n.key}edge(e,t){if(this.multi)throw new A("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new w(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new w(`Graph.edge: could not find the "${t}" target node in the graph.`);const n=r.out&&r.out[t]||r.undirected&&r.undirected[t]||void 0;if(n)return n.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new w(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in r.in||t in r.out}areOutNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new w(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in r.out}areInNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new w(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in r.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new w(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return this.type==="directed"?!1:t in r.undirected}areNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new w(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&(t in r.in||t in r.out)||this.type!=="directed"&&t in r.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new w(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&t in r.in||this.type!=="directed"&&t in r.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new w(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&t in r.out||this.type!=="directed"&&t in r.undirected}inDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.inDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree}outDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.outDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.outDegree}directedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return this.type==="directed"?0:t.undirectedDegree}inboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let r=0;return this.type!=="directed"&&(r+=t.undirectedDegree),this.type!=="undirected"&&(r+=t.inDegree),r}outboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let r=0;return this.type!=="directed"&&(r+=t.undirectedDegree),this.type!=="undirected"&&(r+=t.outDegree),r}degree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.degree: could not find the "${e}" node in the graph.`);let r=0;return this.type!=="directed"&&(r+=t.undirectedDegree),this.type!=="undirected"&&(r+=t.inDegree+t.outDegree),r}inDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);if(this.type==="undirected")return 0;const r=t.in[e],n=r?this.multi?r.size:1:0;return t.inDegree-n}outDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);if(this.type==="undirected")return 0;const r=t.out[e],n=r?this.multi?r.size:1:0;return t.outDegree-n}directedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);if(this.type==="undirected")return 0;const r=t.out[e],n=r?this.multi?r.size:1:0;return t.inDegree+t.outDegree-n*2}undirectedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);if(this.type==="directed")return 0;const r=t.undirected[e],n=r?this.multi?r.size:1:0;return t.undirectedDegree-n*2}inboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r,n=0,s=0;return this.type!=="directed"&&(n+=t.undirectedDegree,r=t.undirected[e],s+=(r?this.multi?r.size:1:0)*2),this.type!=="undirected"&&(n+=t.inDegree,r=t.out[e],s+=r?this.multi?r.size:1:0),n-s}outboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r,n=0,s=0;return this.type!=="directed"&&(n+=t.undirectedDegree,r=t.undirected[e],s+=(r?this.multi?r.size:1:0)*2),this.type!=="undirected"&&(n+=t.outDegree,r=t.in[e],s+=r?this.multi?r.size:1:0),n-s}degreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r,n=0,s=0;return this.type!=="directed"&&(n+=t.undirectedDegree,r=t.undirected[e],s+=(r?this.multi?r.size:1:0)*2),this.type!=="undirected"&&(n+=t.inDegree+t.outDegree,r=t.out[e],s+=(r?this.multi?r.size:1:0)*2),n-s}source(e){e=""+e;const t=this._edges.get(e);if(!t)throw new w(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){e=""+e;const t=this._edges.get(e);if(!t)throw new w(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){e=""+e;const t=this._edges.get(e);if(!t)throw new w(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;const r=this._edges.get(t);if(!r)throw new w(`Graph.opposite: could not find the "${t}" edge in the graph.`);const n=r.source.key,s=r.target.key;if(e===n)return s;if(e===s)return n;throw new w(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${n}, ${s}).`)}hasExtremity(e,t){e=""+e,t=""+t;const r=this._edges.get(e);if(!r)throw new w(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return r.source.key===t||r.target.key===t}isUndirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new w(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new w(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){e=""+e;const t=this._edges.get(e);if(!t)throw new w(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){return ri(this,e,t).key}mergeNode(e,t){if(t&&!J(t))throw new v(`Graph.mergeNode: invalid attributes. Expecting an object but got "${t}"`);e=""+e,t=t||{};let r=this._nodes.get(e);return r?(t&&(H(r.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:r.attributes,data:t})),[e,!1]):(r=new this.NodeDataClass(e,t),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&typeof t!="function")throw new v(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);e=""+e;let r=this._nodes.get(e);if(r){if(t){const s=r.attributes;r.attributes=t(s),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:r.attributes})}return[e,!1]}const n=t?t({}):{};return r=new this.NodeDataClass(e,n),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:n}),[e,!0]}dropNode(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new w(`Graph.dropNode: could not find the "${e}" node in the graph.`);let r;if(this.type!=="undirected"){for(const n in t.out){r=t.out[n];do De(this,r),r=r.next;while(r)}for(const n in t.in){r=t.in[n];do De(this,r),r=r.next;while(r)}}if(this.type!=="directed")for(const n in t.undirected){r=t.undirected[n];do De(this,r),r=r.next;while(r)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:t.attributes})}dropEdge(e){let t;if(arguments.length>1){const r=""+arguments[0],n=""+arguments[1];if(t=oe(this,r,n,this.type),!t)throw new w(`Graph.dropEdge: could not find the "${r}" -> "${n}" edge in the graph.`)}else if(e=""+e,t=this._edges.get(e),!t)throw new w(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return De(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new A("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new A("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");e=""+e,t=""+t;const r=oe(this,e,t,"directed");if(!r)throw new w(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return De(this,r),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new A("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new A("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const r=oe(this,e,t,"undirected");if(!r)throw new w(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return De(this,r),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const e=this._nodes.values();let t;for(;t=e.next(),t.done!==!0;)t.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if(typeof t!="function")throw new v("Graph.updateAttribute: updater should be a function.");const r=this._attributes[e];return this._attributes[e]=t(r),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!J(e))throw new v("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!J(e))throw new v("Graph.mergeAttributes: provided attributes are not a plain object.");return H(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if(typeof e!="function")throw new v("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){if(typeof e!="function")throw new v("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!_t(t))throw new v("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const r=this._nodes.values();let n,s;for(;n=r.next(),n.done!==!0;)s=n.value,s.attributes=e(s.key,s.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){if(typeof e!="function")throw new v("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!_t(t))throw new v("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const r=this._edges.values();let n,s,o,a;for(;n=r.next(),n.done!==!0;)s=n.value,o=s.source,a=s.target,s.attributes=e(s.key,s.attributes,o.key,a.key,o.attributes,a.attributes,s.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if(typeof e!="function")throw new v("Graph.forEachAdjacencyEntry: expecting a callback.");ze(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if(typeof e!="function")throw new v("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");ze(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if(typeof e!="function")throw new v("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");ze(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if(typeof e!="function")throw new v("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");ze(!1,!0,!0,this,e)}nodes(){return typeof Array.from=="function"?Array.from(this._nodes.keys()):wt(this._nodes.keys(),this._nodes.size)}forEachNode(e){if(typeof e!="function")throw new v("Graph.forEachNode: expecting a callback.");const t=this._nodes.values();let r,n;for(;r=t.next(),r.done!==!0;)n=r.value,e(n.key,n.attributes)}findNode(e){if(typeof e!="function")throw new v("Graph.findNode: expecting a callback.");const t=this._nodes.values();let r,n;for(;r=t.next(),r.done!==!0;)if(n=r.value,e(n.key,n.attributes))return n.key}mapNodes(e){if(typeof e!="function")throw new v("Graph.mapNode: expecting a callback.");const t=this._nodes.values();let r,n;const s=new Array(this.order);let o=0;for(;r=t.next(),r.done!==!0;)n=r.value,s[o++]=e(n.key,n.attributes);return s}someNode(e){if(typeof e!="function")throw new v("Graph.someNode: expecting a callback.");const t=this._nodes.values();let r,n;for(;r=t.next(),r.done!==!0;)if(n=r.value,e(n.key,n.attributes))return!0;return!1}everyNode(e){if(typeof e!="function")throw new v("Graph.everyNode: expecting a callback.");const t=this._nodes.values();let r,n;for(;r=t.next(),r.done!==!0;)if(n=r.value,!e(n.key,n.attributes))return!1;return!0}filterNodes(e){if(typeof e!="function")throw new v("Graph.filterNodes: expecting a callback.");const t=this._nodes.values();let r,n;const s=[];for(;r=t.next(),r.done!==!0;)n=r.value,e(n.key,n.attributes)&&s.push(n.key);return s}reduceNodes(e,t){if(typeof e!="function")throw new v("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new v("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let r=t;const n=this._nodes.values();let s,o;for(;s=n.next(),s.done!==!0;)o=s.value,r=e(r,o.key,o.attributes);return r}nodeEntries(){const e=this._nodes.values();return new se(()=>{const t=e.next();if(t.done)return t;const r=t.value;return{value:{node:r.key,attributes:r.attributes},done:!1}})}export(){const e=new Array(this._nodes.size);let t=0;this._nodes.forEach((n,s)=>{e[t++]=Yr(s,n)});const r=new Array(this._edges.size);return t=0,this._edges.forEach((n,s)=>{r[t++]=Vr(s,n)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:r}}import(e,t=!1){if(Xt(e))return e.forEachNode((u,c)=>{t?this.mergeNode(u,c):this.addNode(u,c)}),e.forEachEdge((u,c,p,l,g,D,U)=>{t?U?this.mergeUndirectedEdgeWithKey(u,p,l,c):this.mergeDirectedEdgeWithKey(u,p,l,c):U?this.addUndirectedEdgeWithKey(u,p,l,c):this.addDirectedEdgeWithKey(u,p,l,c)}),this;if(!J(e))throw new v("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!J(e.attributes))throw new v("Graph.import: invalid attributes. Expecting a plain object.");t?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}let r,n,s,o,a;if(e.nodes){if(s=e.nodes,!Array.isArray(s))throw new v("Graph.import: invalid nodes. Expecting an array.");for(r=0,n=s.length;r<n;r++){o=s[r],Qr(o);const{key:u,attributes:c}=o;t?this.mergeNode(u,c):this.addNode(u,c)}}if(e.edges){if(s=e.edges,!Array.isArray(s))throw new v("Graph.import: invalid edges. Expecting an array.");for(r=0,n=s.length;r<n;r++){a=s[r],Jr(a);const{source:u,target:c,attributes:p,undirected:l=!1}=a;let g;"key"in a?(g=t?l?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:l?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,g.call(this,a.key,u,c,p)):(g=t?l?this.mergeUndirectedEdge:this.mergeDirectedEdge:l?this.addUndirectedEdge:this.addDirectedEdge,g.call(this,u,c,p))}}return this}nullCopy(e){const t=new T(H({},this._options,e));return t.replaceAttributes(H({},this.getAttributes())),t}emptyCopy(e){const t=this.nullCopy(e);return this._nodes.forEach((r,n)=>{const s=H({},r.attributes);r=new t.NodeDataClass(n,s),t._nodes.set(n,r)}),t}copy(e){if(e=e||{},typeof e.type=="string"&&e.type!==this.type&&e.type!=="mixed")throw new A(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if(typeof e.multi=="boolean"&&e.multi!==this.multi&&e.multi!==!0)throw new A("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof e.allowSelfLoops=="boolean"&&e.allowSelfLoops!==this.allowSelfLoops&&e.allowSelfLoops!==!0)throw new A("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const t=this.emptyCopy(e),r=this._edges.values();let n,s;for(;n=r.next(),n.done!==!0;)s=n.value,Ct(t,"copy",!1,s.undirected,s.key,s.source.key,s.target.key,H({},s.attributes));return t}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const e={};this._nodes.forEach((s,o)=>{e[o]=s.attributes});const t={},r={};this._edges.forEach((s,o)=>{const a=s.undirected?"--":"->";let u="",c=s.source.key,p=s.target.key,l;s.undirected&&c>p&&(l=c,c=p,p=l);const g=`(${c})${a}(${p})`;o.startsWith("geid_")?this.multi&&(typeof r[g]>"u"?r[g]=0:r[g]++,u+=`${r[g]}. `):u+=`[${o}]: `,u+=g,t[u]=s.attributes});const n={};for(const s in this)this.hasOwnProperty(s)&&!Dt.has(s)&&typeof this[s]!="function"&&typeof s!="symbol"&&(n[s]=this[s]);return n.attributes=this._attributes,n.nodes=e,n.edges=t,ae(n,"constructor",this.constructor),n}}typeof Symbol<"u"&&(T.prototype[Symbol.for("nodejs.util.inspect.custom")]=T.prototype.inspect),ei.forEach(i=>{["add","merge","update"].forEach(e=>{const t=i.name(e),r=e==="add"?Ct:ii;i.generateKey?T.prototype[t]=function(n,s,o){return r(this,t,!0,(i.type||this.type)==="undirected",null,n,s,o,e==="update")}:T.prototype[t]=function(n,s,o,a){return r(this,t,!1,(i.type||this.type)==="undirected",n,s,o,a,e==="update")}})}),fr(T),kr(T),zr(T),Hr(T);class nt extends T{constructor(e){const t=H({type:"directed"},e);if("multi"in t&&t.multi!==!1)throw new v("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="directed")throw new v('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class st extends T{constructor(e){const t=H({type:"undirected"},e);if("multi"in t&&t.multi!==!1)throw new v("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="undirected")throw new v('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class Lt extends T{constructor(e){const t=H({multi:!0},e);if("multi"in t&&t.multi!==!0)throw new v("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(t)}}class Nt extends T{constructor(e){const t=H({type:"directed",multi:!0},e);if("multi"in t&&t.multi!==!0)throw new v("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(t.type!=="directed")throw new v('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class Rt extends T{constructor(e){const t=H({type:"undirected",multi:!0},e);if("multi"in t&&t.multi!==!0)throw new v("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(t.type!=="undirected")throw new v('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}function Se(i){i.from=function(e,t){const r=H({},e.options,t),n=new i(r);return n.import(e),n}}Se(T),Se(nt),Se(st),Se(Lt),Se(Nt),Se(Rt),T.Graph=T,T.DirectedGraph=nt,T.UndirectedGraph=st,T.MultiGraph=Lt,T.MultiDirectedGraph=Nt,T.MultiUndirectedGraph=Rt,T.InvalidArgumentsGraphError=v,T.NotFoundGraphError=w,T.UsageGraphError=A;var Pe={exports:{}};/* @license
Papa Parse
v5.3.2
https://github.com/mholt/PapaParse
License: MIT
*/var ni=Pe.exports,It;function si(){return It||(It=1,function(i,e){(function(t,r){i.exports=r()})(ni,function t(){var r=typeof self<"u"?self:typeof window<"u"?window:r!==void 0?r:{},n=!r.document&&!!r.postMessage,s=n&&/blob:/i.test((r.location||{}).protocol),o={},a=0,u={parse:function(h,d){var f=(d=d||{}).dynamicTyping||!1;if(_(f)&&(d.dynamicTypingFunction=f,f={}),d.dynamicTyping=f,d.transform=!!_(d.transform)&&d.transform,d.worker&&u.WORKERS_SUPPORTED){var E=function(){if(!u.WORKERS_SUPPORTED)return!1;var C=(Z=r.URL||r.webkitURL||null,j=t.toString(),u.BLOB_URL||(u.BLOB_URL=Z.createObjectURL(new Blob(["(",j,")();"],{type:"text/javascript"})))),R=new r.Worker(C),Z,j;return R.onmessage=ne,R.id=a++,o[R.id]=R}();return E.userStep=d.step,E.userChunk=d.chunk,E.userComplete=d.complete,E.userError=d.error,d.step=_(d.step),d.chunk=_(d.chunk),d.complete=_(d.complete),d.error=_(d.error),delete d.worker,void E.postMessage({input:h,config:d,workerId:E.id})}var k=null;return u.NODE_STREAM_INPUT,typeof h=="string"?k=d.download?new l(d):new D(d):h.readable===!0&&_(h.read)&&_(h.on)?k=new U(d):(r.File&&h instanceof File||h instanceof Object)&&(k=new g(d)),k.stream(h)},unparse:function(h,d){var f=!1,E=!0,k=",",C=`\r
`,R='"',Z=R+R,j=!1,x=null,q=!1;(function(){if(typeof d=="object"){if(typeof d.delimiter!="string"||u.BAD_DELIMITERS.filter(function($){return d.delimiter.indexOf($)!==-1}).length||(k=d.delimiter),(typeof d.quotes=="boolean"||typeof d.quotes=="function"||Array.isArray(d.quotes))&&(f=d.quotes),typeof d.skipEmptyLines!="boolean"&&typeof d.skipEmptyLines!="string"||(j=d.skipEmptyLines),typeof d.newline=="string"&&(C=d.newline),typeof d.quoteChar=="string"&&(R=d.quoteChar),typeof d.header=="boolean"&&(E=d.header),Array.isArray(d.columns)){if(d.columns.length===0)throw new Error("Option columns is empty");x=d.columns}d.escapeChar!==void 0&&(Z=d.escapeChar+R),(typeof d.escapeFormulae=="boolean"||d.escapeFormulae instanceof RegExp)&&(q=d.escapeFormulae instanceof RegExp?d.escapeFormulae:/^[=+\-@\t\r].*$/)}})();var S=new RegExp(P(R),"g");if(typeof h=="string"&&(h=JSON.parse(h)),Array.isArray(h)){if(!h.length||Array.isArray(h[0]))return le(null,h,j);if(typeof h[0]=="object")return le(x||Object.keys(h[0]),h,j)}else if(typeof h=="object")return typeof h.data=="string"&&(h.data=JSON.parse(h.data)),Array.isArray(h.data)&&(h.fields||(h.fields=h.meta&&h.meta.fields||x),h.fields||(h.fields=Array.isArray(h.data[0])?h.fields:typeof h.data[0]=="object"?Object.keys(h.data[0]):[]),Array.isArray(h.data[0])||typeof h.data[0]=="object"||(h.data=[h.data])),le(h.fields||[],h.data||[],j);throw new Error("Unable to serialize unrecognized input");function le($,M,te){var F="";typeof $=="string"&&($=JSON.parse($)),typeof M=="string"&&(M=JSON.parse(M));var X=Array.isArray($)&&0<$.length,V=!Array.isArray(M[0]);if(X&&E){for(var Q=0;Q<$.length;Q++)0<Q&&(F+=k),F+=ee($[Q],Q);0<M.length&&(F+=C)}for(var G=0;G<M.length;G++){var O=X?$.length:M[G].length,z=!1,K=X?Object.keys(M[G]).length===0:M[G].length===0;if(te&&!X&&(z=te==="greedy"?M[G].join("").trim()==="":M[G].length===1&&M[G][0].length===0),te==="greedy"&&X){for(var N=[],I=0;I<O;I++){var W=V?$[I]:I;N.push(M[G][W])}z=N.join("").trim()===""}if(!z){for(var L=0;L<O;L++){0<L&&!K&&(F+=k);var ve=X&&V?$[L]:L;F+=ee(M[G][ve],L)}G<M.length-1&&(!te||0<O&&!K)&&(F+=C)}}return F}function ee($,M){if($==null)return"";if($.constructor===Date)return JSON.stringify($).slice(1,25);var te=!1;q&&typeof $=="string"&&q.test($)&&($="'"+$,te=!0);var F=$.toString().replace(S,Z);return(te=te||f===!0||typeof f=="function"&&f($,M)||Array.isArray(f)&&f[M]||function(X,V){for(var Q=0;Q<V.length;Q++)if(-1<X.indexOf(V[Q]))return!0;return!1}(F,u.BAD_DELIMITERS)||-1<F.indexOf(k)||F.charAt(0)===" "||F.charAt(F.length-1)===" ")?R+F+R:F}}};if(u.RECORD_SEP="",u.UNIT_SEP="",u.BYTE_ORDER_MARK="\uFEFF",u.BAD_DELIMITERS=["\r",`
`,'"',u.BYTE_ORDER_MARK],u.WORKERS_SUPPORTED=!n&&!!r.Worker,u.NODE_STREAM_INPUT=1,u.LocalChunkSize=10485760,u.RemoteChunkSize=5242880,u.DefaultDelimiter=",",u.Parser=B,u.ParserHandle=Y,u.NetworkStreamer=l,u.FileStreamer=g,u.StringStreamer=D,u.ReadableStreamStreamer=U,r.jQuery){var c=r.jQuery;c.fn.parse=function(h){var d=h.config||{},f=[];return this.each(function(C){if(!(c(this).prop("tagName").toUpperCase()==="INPUT"&&c(this).attr("type").toLowerCase()==="file"&&r.FileReader)||!this.files||this.files.length===0)return!0;for(var R=0;R<this.files.length;R++)f.push({file:this.files[R],inputElem:this,instanceConfig:c.extend({},d)})}),E(),this;function E(){if(f.length!==0){var C,R,Z,j,x=f[0];if(_(h.before)){var q=h.before(x.file,x.inputElem);if(typeof q=="object"){if(q.action==="abort")return C="AbortError",R=x.file,Z=x.inputElem,j=q.reason,void(_(h.error)&&h.error({name:C},R,Z,j));if(q.action==="skip")return void k();typeof q.config=="object"&&(x.instanceConfig=c.extend(x.instanceConfig,q.config))}else if(q==="skip")return void k()}var S=x.instanceConfig.complete;x.instanceConfig.complete=function(le){_(S)&&S(le,x.file,x.inputElem),k()},u.parse(x.file,x.instanceConfig)}else _(h.complete)&&h.complete()}function k(){f.splice(0,1),E()}}}function p(h){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},(function(d){var f=y(d);f.chunkSize=parseInt(f.chunkSize),d.step||d.chunk||(f.chunkSize=null),this._handle=new Y(f),(this._handle.streamer=this)._config=f}).call(this,h),this.parseChunk=function(d,f){if(this.isFirstChunk&&_(this._config.beforeFirstChunk)){var E=this._config.beforeFirstChunk(d);E!==void 0&&(d=E)}this.isFirstChunk=!1,this._halted=!1;var k=this._partialLine+d;this._partialLine="";var C=this._handle.parse(k,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var R=C.meta.cursor;this._finished||(this._partialLine=k.substring(R-this._baseIndex),this._baseIndex=R),C&&C.data&&(this._rowCount+=C.data.length);var Z=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(s)r.postMessage({results:C,workerId:u.WORKER_ID,finished:Z});else if(_(this._config.chunk)&&!f){if(this._config.chunk(C,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);C=void 0,this._completeResults=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(C.data),this._completeResults.errors=this._completeResults.errors.concat(C.errors),this._completeResults.meta=C.meta),this._completed||!Z||!_(this._config.complete)||C&&C.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),Z||C&&C.meta.paused||this._nextChunk(),C}this._halted=!0},this._sendError=function(d){_(this._config.error)?this._config.error(d):s&&this._config.error&&r.postMessage({workerId:u.WORKER_ID,error:d,finished:!1})}}function l(h){var d;(h=h||{}).chunkSize||(h.chunkSize=u.RemoteChunkSize),p.call(this,h),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(f){this._input=f,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(d=new XMLHttpRequest,this._config.withCredentials&&(d.withCredentials=this._config.withCredentials),n||(d.onload=b(this._chunkLoaded,this),d.onerror=b(this._chunkError,this)),d.open(this._config.downloadRequestBody?"POST":"GET",this._input,!n),this._config.downloadRequestHeaders){var f=this._config.downloadRequestHeaders;for(var E in f)d.setRequestHeader(E,f[E])}if(this._config.chunkSize){var k=this._start+this._config.chunkSize-1;d.setRequestHeader("Range","bytes="+this._start+"-"+k)}try{d.send(this._config.downloadRequestBody)}catch(C){this._chunkError(C.message)}n&&d.status===0&&this._chunkError()}},this._chunkLoaded=function(){d.readyState===4&&(d.status<200||400<=d.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:d.responseText.length,this._finished=!this._config.chunkSize||this._start>=function(f){var E=f.getResponseHeader("Content-Range");return E===null?-1:parseInt(E.substring(E.lastIndexOf("/")+1))}(d),this.parseChunk(d.responseText)))},this._chunkError=function(f){var E=d.statusText||f;this._sendError(new Error(E))}}function g(h){var d,f;(h=h||{}).chunkSize||(h.chunkSize=u.LocalChunkSize),p.call(this,h);var E=typeof FileReader<"u";this.stream=function(k){this._input=k,f=k.slice||k.webkitSlice||k.mozSlice,E?((d=new FileReader).onload=b(this._chunkLoaded,this),d.onerror=b(this._chunkError,this)):d=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var k=this._input;if(this._config.chunkSize){var C=Math.min(this._start+this._config.chunkSize,this._input.size);k=f.call(k,this._start,C)}var R=d.readAsText(k,this._config.encoding);E||this._chunkLoaded({target:{result:R}})},this._chunkLoaded=function(k){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(k.target.result)},this._chunkError=function(){this._sendError(d.error)}}function D(h){var d;p.call(this,h=h||{}),this.stream=function(f){return d=f,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var f,E=this._config.chunkSize;return E?(f=d.substring(0,E),d=d.substring(E)):(f=d,d=""),this._finished=!d,this.parseChunk(f)}}}function U(h){p.call(this,h=h||{});var d=[],f=!0,E=!1;this.pause=function(){p.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){p.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(k){this._input=k,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError)},this._checkIsFinished=function(){E&&d.length===1&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),d.length?this.parseChunk(d.shift()):f=!0},this._streamData=b(function(k){try{d.push(typeof k=="string"?k:k.toString(this._config.encoding)),f&&(f=!1,this._checkIsFinished(),this.parseChunk(d.shift()))}catch(C){this._streamError(C)}},this),this._streamError=b(function(k){this._streamCleanUp(),this._sendError(k)},this),this._streamEnd=b(function(){this._streamCleanUp(),E=!0,this._streamData("")},this),this._streamCleanUp=b(function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError)},this)}function Y(h){var d,f,E,k=Math.pow(2,53),C=-k,R=/^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,Z=/^(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))$/,j=this,x=0,q=0,S=!1,le=!1,ee=[],$={data:[],errors:[],meta:{}};if(_(h.step)){var M=h.step;h.step=function(G){if($=G,X())F();else{if(F(),$.data.length===0)return;x+=G.data.length,h.preview&&x>h.preview?f.abort():($.data=$.data[0],M($,j))}}}function te(G){return h.skipEmptyLines==="greedy"?G.join("").trim()==="":G.length===1&&G[0].length===0}function F(){return $&&E&&(Q("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+u.DefaultDelimiter+"'"),E=!1),h.skipEmptyLines&&($.data=$.data.filter(function(G){return!te(G)})),X()&&function(){if(!$)return;function G(z,K){_(h.transformHeader)&&(z=h.transformHeader(z,K)),ee.push(z)}if(Array.isArray($.data[0])){for(var O=0;X()&&O<$.data.length;O++)$.data[O].forEach(G);$.data.splice(0,1)}else $.data.forEach(G)}(),function(){if(!$||!h.header&&!h.dynamicTyping&&!h.transform)return $;function G(z,K){var N,I=h.header?{}:[];for(N=0;N<z.length;N++){var W=N,L=z[N];h.header&&(W=N>=ee.length?"__parsed_extra":ee[N]),h.transform&&(L=h.transform(L,W)),L=V(W,L),W==="__parsed_extra"?(I[W]=I[W]||[],I[W].push(L)):I[W]=L}return h.header&&(N>ee.length?Q("FieldMismatch","TooManyFields","Too many fields: expected "+ee.length+" fields but parsed "+N,q+K):N<ee.length&&Q("FieldMismatch","TooFewFields","Too few fields: expected "+ee.length+" fields but parsed "+N,q+K)),I}var O=1;return!$.data.length||Array.isArray($.data[0])?($.data=$.data.map(G),O=$.data.length):$.data=G($.data,0),h.header&&$.meta&&($.meta.fields=ee),q+=O,$}()}function X(){return h.header&&ee.length===0}function V(G,O){return z=G,h.dynamicTypingFunction&&h.dynamicTyping[z]===void 0&&(h.dynamicTyping[z]=h.dynamicTypingFunction(z)),(h.dynamicTyping[z]||h.dynamicTyping)===!0?O==="true"||O==="TRUE"||O!=="false"&&O!=="FALSE"&&(function(K){if(R.test(K)){var N=parseFloat(K);if(C<N&&N<k)return!0}return!1}(O)?parseFloat(O):Z.test(O)?new Date(O):O===""?null:O):O;var z}function Q(G,O,z,K){var N={type:G,code:O,message:z};K!==void 0&&(N.row=K),$.errors.push(N)}this.parse=function(G,O,z){var K=h.quoteChar||'"';if(h.newline||(h.newline=function(W,L){W=W.substring(0,1048576);var ve=new RegExp(P(L)+"([^]*?)"+P(L),"gm"),fe=(W=W.replace(ve,"")).split("\r"),ue=W.split(`
`),Ee=1<ue.length&&ue[0].length<fe[0].length;if(fe.length===1||Ee)return`
`;for(var pe=0,he=0;he<fe.length;he++)fe[he][0]===`
`&&pe++;return pe>=fe.length/2?`\r
`:"\r"}(G,K)),E=!1,h.delimiter)_(h.delimiter)&&(h.delimiter=h.delimiter(G),$.meta.delimiter=h.delimiter);else{var N=function(W,L,ve,fe,ue){var Ee,pe,he,re;ue=ue||[",","	","|",";",u.RECORD_SEP,u.UNIT_SEP];for(var ke=0;ke<ue.length;ke++){var ie=ue[ke],Ce=0,be=0,Ot=0;he=void 0;for(var Re=new B({comments:fe,delimiter:ie,newline:L,preview:10}).parse(W),je=0;je<Re.data.length;je++)if(ve&&te(Re.data[je]))Ot++;else{var Ie=Re.data[je].length;be+=Ie,he!==void 0?0<Ie&&(Ce+=Math.abs(Ie-he),he=Ie):he=Ie}0<Re.data.length&&(be/=Re.data.length-Ot),(pe===void 0||Ce<=pe)&&(re===void 0||re<be)&&1.99<be&&(pe=Ce,Ee=ie,re=be)}return{successful:!!(h.delimiter=Ee),bestDelimiter:Ee}}(G,h.newline,h.skipEmptyLines,h.comments,h.delimitersToGuess);N.successful?h.delimiter=N.bestDelimiter:(E=!0,h.delimiter=u.DefaultDelimiter),$.meta.delimiter=h.delimiter}var I=y(h);return h.preview&&h.header&&I.preview++,d=G,f=new B(I),$=f.parse(d,O,z),F(),S?{meta:{paused:!0}}:$||{meta:{paused:!1}}},this.paused=function(){return S},this.pause=function(){S=!0,f.abort(),d=_(h.chunk)?"":d.substring(f.getCharIndex())},this.resume=function(){j.streamer._halted?(S=!1,j.streamer.parseChunk(d,!0)):setTimeout(j.resume,3)},this.aborted=function(){return le},this.abort=function(){le=!0,f.abort(),$.meta.aborted=!0,_(h.complete)&&h.complete($),d=""}}function P(h){return h.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function B(h){var d,f=(h=h||{}).delimiter,E=h.newline,k=h.comments,C=h.step,R=h.preview,Z=h.fastMode,j=d=h.quoteChar===void 0||h.quoteChar===null?'"':h.quoteChar;if(h.escapeChar!==void 0&&(j=h.escapeChar),(typeof f!="string"||-1<u.BAD_DELIMITERS.indexOf(f))&&(f=","),k===f)throw new Error("Comment character same as delimiter");k===!0?k="#":(typeof k!="string"||-1<u.BAD_DELIMITERS.indexOf(k))&&(k=!1),E!==`
`&&E!=="\r"&&E!==`\r
`&&(E=`
`);var x=0,q=!1;this.parse=function(S,le,ee){if(typeof S!="string")throw new Error("Input must be a string");var $=S.length,M=f.length,te=E.length,F=k.length,X=_(C),V=[],Q=[],G=[],O=x=0;if(!S)return re();if(Z||Z!==!1&&S.indexOf(d)===-1){for(var z=S.split(E),K=0;K<z.length;K++){if(G=z[K],x+=G.length,K!==z.length-1)x+=E.length;else if(ee)return re();if(!k||G.substring(0,F)!==k){if(X){if(V=[],ue(G.split(f)),ke(),q)return re()}else ue(G.split(f));if(R&&R<=K)return V=V.slice(0,R),re(!0)}}return re()}for(var N=S.indexOf(f,x),I=S.indexOf(E,x),W=new RegExp(P(j)+P(d),"g"),L=S.indexOf(d,x);;)if(S[x]!==d)if(k&&G.length===0&&S.substring(x,x+F)===k){if(I===-1)return re();x=I+te,I=S.indexOf(E,x),N=S.indexOf(f,x)}else if(N!==-1&&(N<I||I===-1))G.push(S.substring(x,N)),x=N+M,N=S.indexOf(f,x);else{if(I===-1)break;if(G.push(S.substring(x,I)),he(I+te),X&&(ke(),q))return re();if(R&&V.length>=R)return re(!0)}else for(L=x,x++;;){if((L=S.indexOf(d,L+1))===-1)return ee||Q.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:V.length,index:x}),pe();if(L===$-1)return pe(S.substring(x,L).replace(W,d));if(d!==j||S[L+1]!==j){if(d===j||L===0||S[L-1]!==j){N!==-1&&N<L+1&&(N=S.indexOf(f,L+1)),I!==-1&&I<L+1&&(I=S.indexOf(E,L+1));var ve=Ee(I===-1?N:Math.min(N,I));if(S.substr(L+1+ve,M)===f){G.push(S.substring(x,L).replace(W,d)),S[x=L+1+ve+M]!==d&&(L=S.indexOf(d,x)),N=S.indexOf(f,x),I=S.indexOf(E,x);break}var fe=Ee(I);if(S.substring(L+1+fe,L+1+fe+te)===E){if(G.push(S.substring(x,L).replace(W,d)),he(L+1+fe+te),N=S.indexOf(f,x),L=S.indexOf(d,x),X&&(ke(),q))return re();if(R&&V.length>=R)return re(!0);break}Q.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:V.length,index:x}),L++}}else L++}return pe();function ue(ie){V.push(ie),O=x}function Ee(ie){var Ce=0;if(ie!==-1){var be=S.substring(L+1,ie);be&&be.trim()===""&&(Ce=be.length)}return Ce}function pe(ie){return ee||(ie===void 0&&(ie=S.substring(x)),G.push(ie),x=$,ue(G),X&&ke()),re()}function he(ie){x=ie,ue(G),G=[],I=S.indexOf(E,x)}function re(ie){return{data:V,errors:Q,meta:{delimiter:f,linebreak:E,aborted:q,truncated:!!ie,cursor:O+(le||0)}}}function ke(){C(re()),V=[],Q=[]}},this.abort=function(){q=!0},this.getCharIndex=function(){return x}}function ne(h){var d=h.data,f=o[d.workerId],E=!1;if(d.error)f.userError(d.error,d.file);else if(d.results&&d.results.data){var k={abort:function(){E=!0,ce(d.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:m,resume:m};if(_(f.userStep)){for(var C=0;C<d.results.data.length&&(f.userStep({data:d.results.data[C],errors:d.results.errors,meta:d.results.meta},k),!E);C++);delete d.results}else _(f.userChunk)&&(f.userChunk(d.results,k,d.file),delete d.results)}d.finished&&!E&&ce(d.workerId,d.results)}function ce(h,d){var f=o[h];_(f.userComplete)&&f.userComplete(d),f.terminate(),delete o[h]}function m(){throw new Error("Not implemented.")}function y(h){if(typeof h!="object"||h===null)return h;var d=Array.isArray(h)?[]:{};for(var f in h)d[f]=y(h[f]);return d}function b(h,d){return function(){h.apply(d,arguments)}}function _(h){return typeof h=="function"}return s&&(r.onmessage=function(h){var d=h.data;if(u.WORKER_ID===void 0&&d&&(u.WORKER_ID=d.workerId),typeof d.input=="string")r.postMessage({workerId:u.WORKER_ID,results:u.parse(d.input,d.config),finished:!0});else if(r.File&&d.input instanceof File||d.input instanceof Object){var f=u.parse(d.input,d.config);f&&r.postMessage({workerId:u.WORKER_ID,results:f,finished:!0})}}),(l.prototype=Object.create(p.prototype)).constructor=l,(g.prototype=Object.create(p.prototype)).constructor=g,(D.prototype=Object.create(D.prototype)).constructor=D,(U.prototype=Object.create(p.prototype)).constructor=U,u})}(Pe)),Pe.exports}var oi=si();class ai{constructor(e){ge(this,"_table");ge(this,"_header");ge(this,"_parseError");ge(this,"_numRows");const t=new TextDecoder().decode(e);if(t.match(/\ufffd/)){this._parseError="Input file appears to be binary";return}let r;const n=oi.parse(t,{skipEmptyLines:!0});if(n.errors.length>0){this._parseError="DSV Parsing Error: "+[...new Set(n.errors.map(o=>o.code))].join("; ")+" (check that input is in DSV format)";return}else if(n.meta.truncated){this._parseError="DSV Parsing Error: Result was truncated";return}else if(n.meta.aborted){this._parseError="DSV Parsing Error: Result was aborted";return}else r=n.data;if(r.length<2){this._parseError="DSV is empty (contains zero or one rows)";return}for(let o=0;o<r.length;o++)for(let a=0;a<r[o].length;a++)r[o][a]=r[o][a].trim();if(new Set(r[0]).size!=r[0].length){this._parseError=`The header cannot contain duplicates values: ${r[0]}`;return}let s=-1;for(let o=0;o<r.length;o++)if(r[o].length<2){this._parseError=`DSV Parsing Error: Each row much have at least 2 fields, found ${r[o].length}: ${r[o]}`;return}else if(s>=0&&r[o].length!=s){this._parseError="DSV Parsing Error: The number of fields in all rows must be equal";return}else if(r[o].every(a=>a))s=r[o].length;else{this._parseError="DSV Parsing Error: There are empty fields";return}this._table=r.slice(1),this._header=r[0],this._numRows=r.length-1}header(){if(!this._header)throw new Error("Can't be here, header is undefined");return this._header.slice()}numRows(){if(!this._numRows)throw new Error("Can't be here, numRows is undefined");return this._numRows}parseError(){return this._parseError?this._parseError:null}determine(e,t){if(!this._table)throw new Error("Can't be here, table is undefined");let r=!0,n=!0;const s={};for(let o=1;o<this._table.length;o++){const a=this._table[o][e],u=this._table[o][t];if(a in s||(s[a]=new Set),u in s||(s[u]=new Set),s[a].has(u)){n=!1,r=!1;break}s[u].has(a)&&(n=!1),s[a].add(u)}return[r,n]}slice(e,t){if(!this._table)throw new Error("Can't be here, table is undefined");return this._table.slice(e,t)}import(e,t,r){if(!this._table)throw new Error("Can't be here, table is undefined");if(!this._header)throw new Error("Can't be here, header is undefined");const n=[...Array(this._header.length).keys()].filter(o=>o!=e&&o!=t),s=r?new nt:new st;for(let o=0;o<this._table.length;o++){const a=this._table[o][e],u=this._table[o][t];s.hasNode(a)||s.addNode(a),s.hasNode(u)||s.addNode(u);const c={};for(const p of n)c[this._header[p]]=this._table[o][p];s.addEdge(a,u,c)}return s}}class ui{constructor(){ge(this,"queue");ge(this,"graphs");ge(this,"csvImporter");ge(this,"csvImporterIndex");ge(this,"graphChangedCallback");this.queue=[],this.graphs=[],this.graphChangedCallback=function(){}}async queueAddFile(e,t){this.queue.push({name:t||e.name,content:new Promise((r,n)=>{e.arrayBuffer().then(s=>{s?r(s):n("empty file or directory")}).catch(s=>{n(s)})})})}async queueAddURL(e,t){const r=new URL(e);this.queue.push({name:t||e,content:new Promise((n,s)=>{fetch(r).then(o=>{o.status==200?o.arrayBuffer().then(a=>{n(a)}).catch(a=>{s(a)}):s(o.status.toString())}).catch(o=>{s(o)})})})}async queueRemove(e){this.queue.splice(e,1),this.csvImporter=void 0,this.csvImporterIndex=void 0}async queueLength(){return this.queue.length}async queueName(e){return this.queue[e].name}async queueSize(e){let t;try{t=await this.queue[e].content}catch{return null}return t.byteLength}async queueError(e){try{return await this.queue[e].content,null}catch(t){return t}}async csvParse(e){if(e!==this.csvImporterIndex){const t=await this.queue[e].content;this.csvImporter=new ai(t),this.csvImporterIndex=e}if(!this.csvImporter)throw new Error("Can't be here, csvImporter is undefined");return[this.csvImporter.header(),this.csvImporter.parseError(),this.csvImporter.numRows()]}async csvSlice(e,t,r){if(!this.csvImporter)throw new Error("Can't be here, csvImporter cannot be undefined");if(e!=this.csvImporterIndex)throw new Error("Can't be here, csvImporterIndex cannot be undefined");return this.csvImporter.slice(t,r)}async csvDetermine(e,t,r){var n;if(!this.csvImporter)throw new Error("Can't be here, csvImporter cannot be undefined");if(e!=this.csvImporterIndex)throw new Error("Can't be here, csvImporterIndex cannot be undefined");return(n=this.csvImporter)==null?void 0:n.determine(t,r)}async csvImport(e,t,r,n){if(!this.csvImporter)throw new Error("Can't be here, csvImporter cannot be undefined");if(e!=this.csvImporterIndex)throw new Error("Can't be here, csvImporterIndex cannot be undefined");const s=this.csvImporter.import(t,r,n);s.setAttribute("name",this.queue[e].name),this.graphs.push(s),this.graphChangedCallback()}async setGraphChangedCallback(e){this.graphChangedCallback=e}async numGraphs(){return this.graphs.length}async clientGraph(e){return{name:this.graphs[e].getAttribute("name"),order:this.graphs[e].order,size:this.graphs[e].size,directed:this.graphs[e].type=="directed"}}async removeGraph(e){this.graphs.splice(e,1),this.graphChangedCallback()}async degreeDistribution(e,t){if(e>=this.graphs.length)throw new Error(`Index ${e} is outside the bounds of array with length ${this.graphs.length}`);const r=this.graphs[e];if(t=="undirected"&&r.type!=="undirected")throw new Error(`Can't be here, graph must be undirected, got ${t}, graph is ${r.type}`);if((t=="in"||t=="out")&&r.type!=="directed")throw new Error("Can't be here, graph must be directed");const n=new Map;return this.graphs[e].forEachNode(s=>{let o=-1;if(t=="in")o=r.inDegree(s);else if(t=="out")o=r.outDegree(s);else if(t=="undirected")o=r.degree(s);else throw new Error("Can't be here, type must be one of in, out or undirected");n.has(o)||n.set(o,0),n.set(o,n.get(o)+1)}),n}}We(ui)})();
