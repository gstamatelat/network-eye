var vi=Object.defineProperty;var Ei=(me,pe,$e)=>pe in me?vi(me,pe,{enumerable:!0,configurable:!0,writable:!0,value:$e}):me[pe]=$e;var le=(me,pe,$e)=>(Ei(me,typeof pe!="symbol"?pe+"":pe,$e),$e);(function(){"use strict";const me=Symbol("Comlink.proxy"),pe=Symbol("Comlink.endpoint"),$e=Symbol("Comlink.releaseProxy"),We=Symbol("Comlink.thrown"),ot=i=>typeof i=="object"&&i!==null||typeof i=="function",Pt={canHandle:i=>ot(i)&&i[me],serialize(i){const{port1:e,port2:t}=new MessageChannel;return Ke(i,e),[t,[t]]},deserialize(i){return i.start(),Kt(i)}},Ft={canHandle:i=>ot(i)&&We in i,serialize({value:i}){let e;return i instanceof Error?e={isError:!0,value:{message:i.message,name:i.name,stack:i.stack}}:e={isError:!1,value:i},[e,[]]},deserialize(i){throw i.isError?Object.assign(new Error(i.value.message),i.value):i.value}},at=new Map([["proxy",Pt],["throw",Ft]]);function Ke(i,e=self){e.addEventListener("message",function t(r){if(!r||!r.data)return;const{id:n,type:s,path:o}=Object.assign({path:[]},r.data),a=(r.data.argumentList||[]).map(xe);let u;try{const d=o.slice(0,-1).reduce((f,p)=>f[p],i),l=o.reduce((f,p)=>f[p],i);switch(s){case"GET":u=l;break;case"SET":d[o.slice(-1)[0]]=xe(r.data.value),u=!0;break;case"APPLY":u=l.apply(d,a);break;case"CONSTRUCT":{const f=new l(...a);u=Ht(f)}break;case"ENDPOINT":{const{port1:f,port2:p}=new MessageChannel;Ke(i,p),u=Bt(f,[f])}break;case"RELEASE":u=void 0;break;default:return}}catch(d){u={value:d,[We]:0}}Promise.resolve(u).catch(d=>({value:d,[We]:0})).then(d=>{const[l,f]=Be(d);e.postMessage(Object.assign(Object.assign({},l),{id:n}),f),s==="RELEASE"&&(e.removeEventListener("message",t),ut(e))})}),e.start&&e.start()}function Wt(i){return i.constructor.name==="MessagePort"}function ut(i){Wt(i)&&i.close()}function Kt(i,e){return qe(i,[],e)}function Ue(i){if(i)throw new Error("Proxy has been released and is not useable")}function qe(i,e=[],t=function(){}){let r=!1;const n=new Proxy(t,{get(s,o){if(Ue(r),o===$e)return()=>Ae(i,{type:"RELEASE",path:e.map(a=>a.toString())}).then(()=>{ut(i),r=!0});if(o==="then"){if(e.length===0)return{then:()=>n};const a=Ae(i,{type:"GET",path:e.map(u=>u.toString())}).then(xe);return a.then.bind(a)}return qe(i,[...e,o])},set(s,o,a){Ue(r);const[u,d]=Be(a);return Ae(i,{type:"SET",path:[...e,o].map(l=>l.toString()),value:u},d).then(xe)},apply(s,o,a){Ue(r);const u=e[e.length-1];if(u===pe)return Ae(i,{type:"ENDPOINT"}).then(xe);if(u==="bind")return qe(i,e.slice(0,-1));const[d,l]=ht(a);return Ae(i,{type:"APPLY",path:e.map(f=>f.toString()),argumentList:d},l).then(xe)},construct(s,o){Ue(r);const[a,u]=ht(o);return Ae(i,{type:"CONSTRUCT",path:e.map(d=>d.toString()),argumentList:a},u).then(xe)}});return n}function qt(i){return Array.prototype.concat.apply([],i)}function ht(i){const e=i.map(Be);return[e.map(t=>t[0]),qt(e.map(t=>t[1]))]}const dt=new WeakMap;function Bt(i,e){return dt.set(i,e),i}function Ht(i){return Object.assign(i,{[me]:!0})}function Be(i){for(const[e,t]of at)if(t.canHandle(i)){const[r,n]=t.serialize(i);return[{type:"HANDLER",name:e,value:r},n]}return[{type:"RAW",value:i},dt.get(i)||[]]}function xe(i){switch(i.type){case"HANDLER":return at.get(i.name).deserialize(i.value);case"RAW":return i.value}}function Ae(i,e,t){return new Promise(r=>{const n=Yt();i.addEventListener("message",function s(o){!o.data||!o.data.id||o.data.id!==n||(i.removeEventListener("message",s),r(o.data))}),i.start&&i.start(),i.postMessage(Object.assign({id:n},e),t)})}function Yt(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}var Vt=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function He(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var ct={exports:{}};/* @license
Papa Parse
v5.3.2
https://github.com/mholt/PapaParse
License: MIT
*/(function(i,e){(function(t,r){i.exports=r()})(Vt,function t(){var r=typeof self<"u"?self:typeof window<"u"?window:r!==void 0?r:{},n=!r.document&&!!r.postMessage,s=n&&/blob:/i.test((r.location||{}).protocol),o={},a=0,u={parse:function(c,h){var g=(h=h||{}).dynamicTyping||!1;if(O(g)&&(h.dynamicTypingFunction=g,g={}),h.dynamicTyping=g,h.transform=!!O(h.transform)&&h.transform,h.worker&&u.WORKERS_SUPPORTED){var b=function(){if(!u.WORKERS_SUPPORTED)return!1;var G=(Q=r.URL||r.webkitURL||null,M=t.toString(),u.BLOB_URL||(u.BLOB_URL=Q.createObjectURL(new Blob(["(",M,")();"],{type:"text/javascript"})))),S=new r.Worker(G),Q,M;return S.onmessage=se,S.id=a++,o[S.id]=S}();return b.userStep=h.step,b.userChunk=h.chunk,b.userComplete=h.complete,b.userError=h.error,h.step=O(h.step),h.chunk=O(h.chunk),h.complete=O(h.complete),h.error=O(h.error),delete h.worker,void b.postMessage({input:c,config:h,workerId:b.id})}var _=null;return u.NODE_STREAM_INPUT,typeof c=="string"?_=h.download?new f(h):new $(h):c.readable===!0&&O(c.read)&&O(c.on)?_=new R(h):(r.File&&c instanceof File||c instanceof Object)&&(_=new p(h)),_.stream(c)},unparse:function(c,h){var g=!1,b=!0,_=",",G=`\r
`,S='"',Q=S+S,M=!1,v=null,F=!1;(function(){if(typeof h=="object"){if(typeof h.delimiter!="string"||u.BAD_DELIMITERS.filter(function(m){return h.delimiter.indexOf(m)!==-1}).length||(_=h.delimiter),(typeof h.quotes=="boolean"||typeof h.quotes=="function"||Array.isArray(h.quotes))&&(g=h.quotes),typeof h.skipEmptyLines!="boolean"&&typeof h.skipEmptyLines!="string"||(M=h.skipEmptyLines),typeof h.newline=="string"&&(G=h.newline),typeof h.quoteChar=="string"&&(S=h.quoteChar),typeof h.header=="boolean"&&(b=h.header),Array.isArray(h.columns)){if(h.columns.length===0)throw new Error("Option columns is empty");v=h.columns}h.escapeChar!==void 0&&(Q=h.escapeChar+S),(typeof h.escapeFormulae=="boolean"||h.escapeFormulae instanceof RegExp)&&(F=h.escapeFormulae instanceof RegExp?h.escapeFormulae:/^[=+\-@\t\r].*$/)}})();var x=new RegExp(P(S),"g");if(typeof c=="string"&&(c=JSON.parse(c)),Array.isArray(c)){if(!c.length||Array.isArray(c[0]))return ce(null,c,M);if(typeof c[0]=="object")return ce(v||Object.keys(c[0]),c,M)}else if(typeof c=="object")return typeof c.data=="string"&&(c.data=JSON.parse(c.data)),Array.isArray(c.data)&&(c.fields||(c.fields=c.meta&&c.meta.fields||v),c.fields||(c.fields=Array.isArray(c.data[0])?c.fields:typeof c.data[0]=="object"?Object.keys(c.data[0]):[]),Array.isArray(c.data[0])||typeof c.data[0]=="object"||(c.data=[c.data])),ce(c.fields||[],c.data||[],M);throw new Error("Unable to serialize unrecognized input");function ce(m,U,X){var z="";typeof m=="string"&&(m=JSON.parse(m)),typeof U=="string"&&(U=JSON.parse(U));var J=Array.isArray(m)&&0<m.length,B=!Array.isArray(U[0]);if(J&&b){for(var H=0;H<m.length;H++)0<H&&(z+=_),z+=Z(m[H],H);0<U.length&&(z+=G)}for(var k=0;k<U.length;k++){var L=J?m.length:U[k].length,T=!1,W=J?Object.keys(U[k]).length===0:U[k].length===0;if(X&&!J&&(T=X==="greedy"?U[k].join("").trim()==="":U[k].length===1&&U[k][0].length===0),X==="greedy"&&J){for(var D=[],C=0;C<L;C++){var j=B?m[C]:C;D.push(U[k][j])}T=D.join("").trim()===""}if(!T){for(var A=0;A<L;A++){0<A&&!W&&(z+=_);var ve=J&&B?m[A]:A;z+=Z(U[k][ve],A)}k<U.length-1&&(!X||0<L&&!W)&&(z+=G)}}return z}function Z(m,U){if(m==null)return"";if(m.constructor===Date)return JSON.stringify(m).slice(1,25);var X=!1;F&&typeof m=="string"&&F.test(m)&&(m="'"+m,X=!0);var z=m.toString().replace(x,Q);return(X=X||g===!0||typeof g=="function"&&g(m,U)||Array.isArray(g)&&g[U]||function(J,B){for(var H=0;H<B.length;H++)if(-1<J.indexOf(B[H]))return!0;return!1}(z,u.BAD_DELIMITERS)||-1<z.indexOf(_)||z.charAt(0)===" "||z.charAt(z.length-1)===" ")?S+z+S:z}}};if(u.RECORD_SEP=String.fromCharCode(30),u.UNIT_SEP=String.fromCharCode(31),u.BYTE_ORDER_MARK="\uFEFF",u.BAD_DELIMITERS=["\r",`
`,'"',u.BYTE_ORDER_MARK],u.WORKERS_SUPPORTED=!n&&!!r.Worker,u.NODE_STREAM_INPUT=1,u.LocalChunkSize=10485760,u.RemoteChunkSize=5242880,u.DefaultDelimiter=",",u.Parser=q,u.ParserHandle=V,u.NetworkStreamer=f,u.FileStreamer=p,u.StringStreamer=$,u.ReadableStreamStreamer=R,r.jQuery){var d=r.jQuery;d.fn.parse=function(c){var h=c.config||{},g=[];return this.each(function(G){if(!(d(this).prop("tagName").toUpperCase()==="INPUT"&&d(this).attr("type").toLowerCase()==="file"&&r.FileReader)||!this.files||this.files.length===0)return!0;for(var S=0;S<this.files.length;S++)g.push({file:this.files[S],inputElem:this,instanceConfig:d.extend({},h)})}),b(),this;function b(){if(g.length!==0){var G,S,Q,M,v=g[0];if(O(c.before)){var F=c.before(v.file,v.inputElem);if(typeof F=="object"){if(F.action==="abort")return G="AbortError",S=v.file,Q=v.inputElem,M=F.reason,void(O(c.error)&&c.error({name:G},S,Q,M));if(F.action==="skip")return void _();typeof F.config=="object"&&(v.instanceConfig=d.extend(v.instanceConfig,F.config))}else if(F==="skip")return void _()}var x=v.instanceConfig.complete;v.instanceConfig.complete=function(ce){O(x)&&x(ce,v.file,v.inputElem),_()},u.parse(v.file,v.instanceConfig)}else O(c.complete)&&c.complete()}function _(){g.splice(0,1),b()}}}function l(c){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(h){var g=st(h);g.chunkSize=parseInt(g.chunkSize),h.step||h.chunk||(g.chunkSize=null),this._handle=new V(g),(this._handle.streamer=this)._config=g}.call(this,c),this.parseChunk=function(h,g){if(this.isFirstChunk&&O(this._config.beforeFirstChunk)){var b=this._config.beforeFirstChunk(h);b!==void 0&&(h=b)}this.isFirstChunk=!1,this._halted=!1;var _=this._partialLine+h;this._partialLine="";var G=this._handle.parse(_,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var S=G.meta.cursor;this._finished||(this._partialLine=_.substring(S-this._baseIndex),this._baseIndex=S),G&&G.data&&(this._rowCount+=G.data.length);var Q=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(s)r.postMessage({results:G,workerId:u.WORKER_ID,finished:Q});else if(O(this._config.chunk)&&!g){if(this._config.chunk(G,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);G=void 0,this._completeResults=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(G.data),this._completeResults.errors=this._completeResults.errors.concat(G.errors),this._completeResults.meta=G.meta),this._completed||!Q||!O(this._config.complete)||G&&G.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),Q||G&&G.meta.paused||this._nextChunk(),G}this._halted=!0},this._sendError=function(h){O(this._config.error)?this._config.error(h):s&&this._config.error&&r.postMessage({workerId:u.WORKER_ID,error:h,finished:!1})}}function f(c){var h;(c=c||{}).chunkSize||(c.chunkSize=u.RemoteChunkSize),l.call(this,c),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(g){this._input=g,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(h=new XMLHttpRequest,this._config.withCredentials&&(h.withCredentials=this._config.withCredentials),n||(h.onload=_e(this._chunkLoaded,this),h.onerror=_e(this._chunkError,this)),h.open(this._config.downloadRequestBody?"POST":"GET",this._input,!n),this._config.downloadRequestHeaders){var g=this._config.downloadRequestHeaders;for(var b in g)h.setRequestHeader(b,g[b])}if(this._config.chunkSize){var _=this._start+this._config.chunkSize-1;h.setRequestHeader("Range","bytes="+this._start+"-"+_)}try{h.send(this._config.downloadRequestBody)}catch(G){this._chunkError(G.message)}n&&h.status===0&&this._chunkError()}},this._chunkLoaded=function(){h.readyState===4&&(h.status<200||400<=h.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:h.responseText.length,this._finished=!this._config.chunkSize||this._start>=function(g){var b=g.getResponseHeader("Content-Range");return b===null?-1:parseInt(b.substring(b.lastIndexOf("/")+1))}(h),this.parseChunk(h.responseText)))},this._chunkError=function(g){var b=h.statusText||g;this._sendError(new Error(b))}}function p(c){var h,g;(c=c||{}).chunkSize||(c.chunkSize=u.LocalChunkSize),l.call(this,c);var b=typeof FileReader<"u";this.stream=function(_){this._input=_,g=_.slice||_.webkitSlice||_.mozSlice,b?((h=new FileReader).onload=_e(this._chunkLoaded,this),h.onerror=_e(this._chunkError,this)):h=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var _=this._input;if(this._config.chunkSize){var G=Math.min(this._start+this._config.chunkSize,this._input.size);_=g.call(_,this._start,G)}var S=h.readAsText(_,this._config.encoding);b||this._chunkLoaded({target:{result:S}})},this._chunkLoaded=function(_){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(_.target.result)},this._chunkError=function(){this._sendError(h.error)}}function $(c){var h;l.call(this,c=c||{}),this.stream=function(g){return h=g,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var g,b=this._config.chunkSize;return b?(g=h.substring(0,b),h=h.substring(b)):(g=h,h=""),this._finished=!h,this.parseChunk(g)}}}function R(c){l.call(this,c=c||{});var h=[],g=!0,b=!1;this.pause=function(){l.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){l.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(_){this._input=_,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError)},this._checkIsFinished=function(){b&&h.length===1&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),h.length?this.parseChunk(h.shift()):g=!0},this._streamData=_e(function(_){try{h.push(typeof _=="string"?_:_.toString(this._config.encoding)),g&&(g=!1,this._checkIsFinished(),this.parseChunk(h.shift()))}catch(G){this._streamError(G)}},this),this._streamError=_e(function(_){this._streamCleanUp(),this._sendError(_)},this),this._streamEnd=_e(function(){this._streamCleanUp(),b=!0,this._streamData("")},this),this._streamCleanUp=_e(function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError)},this)}function V(c){var h,g,b,_=Math.pow(2,53),G=-_,S=/^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,Q=/^(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))$/,M=this,v=0,F=0,x=!1,ce=!1,Z=[],m={data:[],errors:[],meta:{}};if(O(c.step)){var U=c.step;c.step=function(k){if(m=k,J())z();else{if(z(),m.data.length===0)return;v+=k.data.length,c.preview&&v>c.preview?g.abort():(m.data=m.data[0],U(m,M))}}}function X(k){return c.skipEmptyLines==="greedy"?k.join("").trim()==="":k.length===1&&k[0].length===0}function z(){return m&&b&&(H("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+u.DefaultDelimiter+"'"),b=!1),c.skipEmptyLines&&(m.data=m.data.filter(function(k){return!X(k)})),J()&&function(){if(!m)return;function k(T,W){O(c.transformHeader)&&(T=c.transformHeader(T,W)),Z.push(T)}if(Array.isArray(m.data[0])){for(var L=0;J()&&L<m.data.length;L++)m.data[L].forEach(k);m.data.splice(0,1)}else m.data.forEach(k)}(),function(){if(!m||!c.header&&!c.dynamicTyping&&!c.transform)return m;function k(T,W){var D,C=c.header?{}:[];for(D=0;D<T.length;D++){var j=D,A=T[D];c.header&&(j=D>=Z.length?"__parsed_extra":Z[D]),c.transform&&(A=c.transform(A,j)),A=B(j,A),j==="__parsed_extra"?(C[j]=C[j]||[],C[j].push(A)):C[j]=A}return c.header&&(D>Z.length?H("FieldMismatch","TooManyFields","Too many fields: expected "+Z.length+" fields but parsed "+D,F+W):D<Z.length&&H("FieldMismatch","TooFewFields","Too few fields: expected "+Z.length+" fields but parsed "+D,F+W)),C}var L=1;return!m.data.length||Array.isArray(m.data[0])?(m.data=m.data.map(k),L=m.data.length):m.data=k(m.data,0),c.header&&m.meta&&(m.meta.fields=Z),F+=L,m}()}function J(){return c.header&&Z.length===0}function B(k,L){return T=k,c.dynamicTypingFunction&&c.dynamicTyping[T]===void 0&&(c.dynamicTyping[T]=c.dynamicTypingFunction(T)),(c.dynamicTyping[T]||c.dynamicTyping)===!0?L==="true"||L==="TRUE"||L!=="false"&&L!=="FALSE"&&(function(W){if(S.test(W)){var D=parseFloat(W);if(G<D&&D<_)return!0}return!1}(L)?parseFloat(L):Q.test(L)?new Date(L):L===""?null:L):L;var T}function H(k,L,T,W){var D={type:k,code:L,message:T};W!==void 0&&(D.row=W),m.errors.push(D)}this.parse=function(k,L,T){var W=c.quoteChar||'"';if(c.newline||(c.newline=function(j,A){j=j.substring(0,1048576);var ve=new RegExp(P(A)+"([^]*?)"+P(A),"gm"),he=(j=j.replace(ve,"")).split("\r"),oe=j.split(`
`),Ee=1<oe.length&&oe[0].length<he[0].length;if(he.length===1||Ee)return`
`;for(var fe=0,ae=0;ae<he.length;ae++)he[ae][0]===`
`&&fe++;return fe>=he.length/2?`\r
`:"\r"}(k,W)),b=!1,c.delimiter)O(c.delimiter)&&(c.delimiter=c.delimiter(k),m.meta.delimiter=c.delimiter);else{var D=function(j,A,ve,he,oe){var Ee,fe,ae,ee;oe=oe||[",","	","|",";",u.RECORD_SEP,u.UNIT_SEP];for(var ke=0;ke<oe.length;ke++){var te=oe[ke],Le=0,we=0,jt=0;ae=void 0;for(var Ie=new q({comments:he,delimiter:te,newline:A,preview:10}).parse(j),Fe=0;Fe<Ie.data.length;Fe++)if(ve&&X(Ie.data[Fe]))jt++;else{var Oe=Ie.data[Fe].length;we+=Oe,ae!==void 0?0<Oe&&(Le+=Math.abs(Oe-ae),ae=Oe):ae=Oe}0<Ie.data.length&&(we/=Ie.data.length-jt),(fe===void 0||Le<=fe)&&(ee===void 0||ee<we)&&1.99<we&&(fe=Le,Ee=te,ee=we)}return{successful:!!(c.delimiter=Ee),bestDelimiter:Ee}}(k,c.newline,c.skipEmptyLines,c.comments,c.delimitersToGuess);D.successful?c.delimiter=D.bestDelimiter:(b=!0,c.delimiter=u.DefaultDelimiter),m.meta.delimiter=c.delimiter}var C=st(c);return c.preview&&c.header&&C.preview++,h=k,g=new q(C),m=g.parse(h,L,T),z(),x?{meta:{paused:!0}}:m||{meta:{paused:!1}}},this.paused=function(){return x},this.pause=function(){x=!0,g.abort(),h=O(c.chunk)?"":h.substring(g.getCharIndex())},this.resume=function(){M.streamer._halted?(x=!1,M.streamer.parseChunk(h,!0)):setTimeout(M.resume,3)},this.aborted=function(){return ce},this.abort=function(){ce=!0,g.abort(),m.meta.aborted=!0,O(c.complete)&&c.complete(m),h=""}}function P(c){return c.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function q(c){var h,g=(c=c||{}).delimiter,b=c.newline,_=c.comments,G=c.step,S=c.preview,Q=c.fastMode,M=h=c.quoteChar===void 0||c.quoteChar===null?'"':c.quoteChar;if(c.escapeChar!==void 0&&(M=c.escapeChar),(typeof g!="string"||-1<u.BAD_DELIMITERS.indexOf(g))&&(g=","),_===g)throw new Error("Comment character same as delimiter");_===!0?_="#":(typeof _!="string"||-1<u.BAD_DELIMITERS.indexOf(_))&&(_=!1),b!==`
`&&b!=="\r"&&b!==`\r
`&&(b=`
`);var v=0,F=!1;this.parse=function(x,ce,Z){if(typeof x!="string")throw new Error("Input must be a string");var m=x.length,U=g.length,X=b.length,z=_.length,J=O(G),B=[],H=[],k=[],L=v=0;if(!x)return ee();if(Q||Q!==!1&&x.indexOf(h)===-1){for(var T=x.split(b),W=0;W<T.length;W++){if(k=T[W],v+=k.length,W!==T.length-1)v+=b.length;else if(Z)return ee();if(!_||k.substring(0,z)!==_){if(J){if(B=[],oe(k.split(g)),ke(),F)return ee()}else oe(k.split(g));if(S&&S<=W)return B=B.slice(0,S),ee(!0)}}return ee()}for(var D=x.indexOf(g,v),C=x.indexOf(b,v),j=new RegExp(P(M)+P(h),"g"),A=x.indexOf(h,v);;)if(x[v]!==h)if(_&&k.length===0&&x.substring(v,v+z)===_){if(C===-1)return ee();v=C+X,C=x.indexOf(b,v),D=x.indexOf(g,v)}else if(D!==-1&&(D<C||C===-1))k.push(x.substring(v,D)),v=D+U,D=x.indexOf(g,v);else{if(C===-1)break;if(k.push(x.substring(v,C)),ae(C+X),J&&(ke(),F))return ee();if(S&&B.length>=S)return ee(!0)}else for(A=v,v++;;){if((A=x.indexOf(h,A+1))===-1)return Z||H.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:B.length,index:v}),fe();if(A===m-1)return fe(x.substring(v,A).replace(j,h));if(h!==M||x[A+1]!==M){if(h===M||A===0||x[A-1]!==M){D!==-1&&D<A+1&&(D=x.indexOf(g,A+1)),C!==-1&&C<A+1&&(C=x.indexOf(b,A+1));var ve=Ee(C===-1?D:Math.min(D,C));if(x.substr(A+1+ve,U)===g){k.push(x.substring(v,A).replace(j,h)),x[v=A+1+ve+U]!==h&&(A=x.indexOf(h,v)),D=x.indexOf(g,v),C=x.indexOf(b,v);break}var he=Ee(C);if(x.substring(A+1+he,A+1+he+X)===b){if(k.push(x.substring(v,A).replace(j,h)),ae(A+1+he+X),D=x.indexOf(g,v),A=x.indexOf(h,v),J&&(ke(),F))return ee();if(S&&B.length>=S)return ee(!0);break}H.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:B.length,index:v}),A++}}else A++}return fe();function oe(te){B.push(te),L=v}function Ee(te){var Le=0;if(te!==-1){var we=x.substring(A+1,te);we&&we.trim()===""&&(Le=we.length)}return Le}function fe(te){return Z||(te===void 0&&(te=x.substring(v)),k.push(te),v=m,oe(k),J&&ke()),ee()}function ae(te){v=te,oe(k),k=[],C=x.indexOf(b,v)}function ee(te){return{data:B,errors:H,meta:{delimiter:g,linebreak:b,aborted:F,truncated:!!te,cursor:L+(ce||0)}}}function ke(){G(ee()),B=[],H=[]}},this.abort=function(){F=!0},this.getCharIndex=function(){return v}}function se(c){var h=c.data,g=o[h.workerId],b=!1;if(h.error)g.userError(h.error,h.file);else if(h.results&&h.results.data){var _={abort:function(){b=!0,be(h.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:Pe,resume:Pe};if(O(g.userStep)){for(var G=0;G<h.results.data.length&&(g.userStep({data:h.results.data[G],errors:h.results.errors,meta:h.results.meta},_),!b);G++);delete h.results}else O(g.userChunk)&&(g.userChunk(h.results,_,h.file),delete h.results)}h.finished&&!b&&be(h.workerId,h.results)}function be(c,h){var g=o[c];O(g.userComplete)&&g.userComplete(h),g.terminate(),delete o[c]}function Pe(){throw new Error("Not implemented.")}function st(c){if(typeof c!="object"||c===null)return c;var h=Array.isArray(c)?[]:{};for(var g in c)h[g]=st(c[g]);return h}function _e(c,h){return function(){c.apply(h,arguments)}}function O(c){return typeof c=="function"}return s&&(r.onmessage=function(c){var h=c.data;if(u.WORKER_ID===void 0&&h&&(u.WORKER_ID=h.workerId),typeof h.input=="string")r.postMessage({workerId:u.WORKER_ID,results:u.parse(h.input,h.config),finished:!0});else if(r.File&&h.input instanceof File||h.input instanceof Object){var g=u.parse(h.input,h.config);g&&r.postMessage({workerId:u.WORKER_ID,results:g,finished:!0})}}),(f.prototype=Object.create(l.prototype)).constructor=f,(p.prototype=Object.create(l.prototype)).constructor=p,($.prototype=Object.create($.prototype)).constructor=$,(R.prototype=Object.create(l.prototype)).constructor=R,u})})(ct);var Qt=ct.exports,Ye={exports:{}},Ge=typeof Reflect=="object"?Reflect:null,ft=Ge&&typeof Ge.apply=="function"?Ge.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)},Te;Ge&&typeof Ge.ownKeys=="function"?Te=Ge.ownKeys:Object.getOwnPropertySymbols?Te=function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:Te=function(e){return Object.getOwnPropertyNames(e)};function Jt(i){console&&console.warn&&console.warn(i)}var lt=Number.isNaN||function(e){return e!==e};function N(){N.init.call(this)}Ye.exports=N,Ye.exports.once=tr,N.EventEmitter=N,N.prototype._events=void 0,N.prototype._eventsCount=0,N.prototype._maxListeners=void 0;var pt=10;function Me(i){if(typeof i!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof i)}Object.defineProperty(N,"defaultMaxListeners",{enumerable:!0,get:function(){return pt},set:function(i){if(typeof i!="number"||i<0||lt(i))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+i+".");pt=i}}),N.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},N.prototype.setMaxListeners=function(e){if(typeof e!="number"||e<0||lt(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this};function gt(i){return i._maxListeners===void 0?N.defaultMaxListeners:i._maxListeners}N.prototype.getMaxListeners=function(){return gt(this)},N.prototype.emit=function(e){for(var t=[],r=1;r<arguments.length;r++)t.push(arguments[r]);var n=e==="error",s=this._events;if(s!==void 0)n=n&&s.error===void 0;else if(!n)return!1;if(n){var o;if(t.length>0&&(o=t[0]),o instanceof Error)throw o;var a=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw a.context=o,a}var u=s[e];if(u===void 0)return!1;if(typeof u=="function")ft(u,this,t);else for(var d=u.length,l=_t(u,d),r=0;r<d;++r)ft(l[r],this,t);return!0};function yt(i,e,t,r){var n,s,o;if(Me(t),s=i._events,s===void 0?(s=i._events=Object.create(null),i._eventsCount=0):(s.newListener!==void 0&&(i.emit("newListener",e,t.listener?t.listener:t),s=i._events),o=s[e]),o===void 0)o=s[e]=t,++i._eventsCount;else if(typeof o=="function"?o=s[e]=r?[t,o]:[o,t]:r?o.unshift(t):o.push(t),n=gt(i),n>0&&o.length>n&&!o.warned){o.warned=!0;var a=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");a.name="MaxListenersExceededWarning",a.emitter=i,a.type=e,a.count=o.length,Jt(a)}return i}N.prototype.addListener=function(e,t){return yt(this,e,t,!1)},N.prototype.on=N.prototype.addListener,N.prototype.prependListener=function(e,t){return yt(this,e,t,!0)};function Zt(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function wt(i,e,t){var r={fired:!1,wrapFn:void 0,target:i,type:e,listener:t},n=Zt.bind(r);return n.listener=t,r.wrapFn=n,n}N.prototype.once=function(e,t){return Me(t),this.on(e,wt(this,e,t)),this},N.prototype.prependOnceListener=function(e,t){return Me(t),this.prependListener(e,wt(this,e,t)),this},N.prototype.removeListener=function(e,t){var r,n,s,o,a;if(Me(t),n=this._events,n===void 0)return this;if(r=n[e],r===void 0)return this;if(r===t||r.listener===t)--this._eventsCount===0?this._events=Object.create(null):(delete n[e],n.removeListener&&this.emit("removeListener",e,r.listener||t));else if(typeof r!="function"){for(s=-1,o=r.length-1;o>=0;o--)if(r[o]===t||r[o].listener===t){a=r[o].listener,s=o;break}if(s<0)return this;s===0?r.shift():Xt(r,s),r.length===1&&(n[e]=r[0]),n.removeListener!==void 0&&this.emit("removeListener",e,a||t)}return this},N.prototype.off=N.prototype.removeListener,N.prototype.removeAllListeners=function(e){var t,r,n;if(r=this._events,r===void 0)return this;if(r.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):r[e]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete r[e]),this;if(arguments.length===0){var s=Object.keys(r),o;for(n=0;n<s.length;++n)o=s[n],o!=="removeListener"&&this.removeAllListeners(o);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(t=r[e],typeof t=="function")this.removeListener(e,t);else if(t!==void 0)for(n=t.length-1;n>=0;n--)this.removeListener(e,t[n]);return this};function mt(i,e,t){var r=i._events;if(r===void 0)return[];var n=r[e];return n===void 0?[]:typeof n=="function"?t?[n.listener||n]:[n]:t?er(n):_t(n,n.length)}N.prototype.listeners=function(e){return mt(this,e,!0)},N.prototype.rawListeners=function(e){return mt(this,e,!1)},N.listenerCount=function(i,e){return typeof i.listenerCount=="function"?i.listenerCount(e):bt.call(i,e)},N.prototype.listenerCount=bt;function bt(i){var e=this._events;if(e!==void 0){var t=e[i];if(typeof t=="function")return 1;if(t!==void 0)return t.length}return 0}N.prototype.eventNames=function(){return this._eventsCount>0?Te(this._events):[]};function _t(i,e){for(var t=new Array(e),r=0;r<e;++r)t[r]=i[r];return t}function Xt(i,e){for(;e+1<i.length;e++)i[e]=i[e+1];i.pop()}function er(i){for(var e=new Array(i.length),t=0;t<e.length;++t)e[t]=i[t].listener||i[t];return e}function tr(i,e){return new Promise(function(t,r){function n(o){i.removeListener(e,s),r(o)}function s(){typeof i.removeListener=="function"&&i.removeListener("error",n),t([].slice.call(arguments))}vt(i,e,s,{once:!0}),e!=="error"&&rr(i,n,{once:!0})})}function rr(i,e,t){typeof i.on=="function"&&vt(i,"error",e,t)}function vt(i,e,t,r){if(typeof i.on=="function")r.once?i.once(e,t):i.on(e,t);else if(typeof i.addEventListener=="function")i.addEventListener(e,function n(s){r.once&&i.removeEventListener(e,n),t(s)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof i)}var ir=Ye.exports;function de(i){if(typeof i!="function")throw new Error("obliterator/iterator: expecting a function!");this.next=i}typeof Symbol<"u"&&(de.prototype[Symbol.iterator]=function(){return this}),de.of=function(){var i=arguments,e=i.length,t=0;return new de(function(){return t>=e?{done:!0}:{done:!1,value:i[t++]}})},de.empty=function(){var i=new de(function(){return{done:!0}});return i},de.fromSequence=function(i){var e=0,t=i.length;return new de(function(){return e>=t?{done:!0}:{done:!1,value:i[e++]}})},de.is=function(i){return i instanceof de?!0:typeof i=="object"&&i!==null&&typeof i.next=="function"};var Ve=de,re=He(Ve),Qe={};Qe.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer<"u",Qe.SYMBOL_SUPPORT=typeof Symbol<"u";var nr=Ve,Et=Qe,sr=Et.ARRAY_BUFFER_SUPPORT,or=Et.SYMBOL_SUPPORT;function ar(i){return typeof i=="string"||Array.isArray(i)||sr&&ArrayBuffer.isView(i)?nr.fromSequence(i):typeof i!="object"||i===null?null:or&&typeof i[Symbol.iterator]=="function"?i[Symbol.iterator]():typeof i.next=="function"?i:null}var kt=function(e){var t=ar(e);if(!t)throw new Error("obliterator: target is not iterable nor a valid iterator.");return t},ur=kt,hr=function(e,t){for(var r=arguments.length>1?t:1/0,n=r!==1/0?new Array(r):[],s,o=0,a=ur(e);;){if(o===r)return n;if(s=a.next(),s.done)return o!==t&&(n.length=o),n;n[o++]=s.value}},$t=He(hr),dr=Ve,cr=kt,fr=function(){var e=arguments,t=null,r=-1;return new dr(function(){var s=null;do{if(t===null){if(r++,r>=e.length)return{done:!0};t=cr(e[r])}if(s=t.next(),s.done===!0){t=null;continue}break}while(!0);return s})},ge=He(fr);function lr(){const i=arguments[0];for(let e=1,t=arguments.length;e<t;e++)if(arguments[e])for(const r in arguments[e])i[r]=arguments[e][r];return i}let K=lr;typeof Object.assign=="function"&&(K=Object.assign);function ie(i,e,t,r){const n=i._nodes.get(e);let s=null;return n&&(r==="mixed"?s=n.out&&n.out[t]||n.undirected&&n.undirected[t]:r==="directed"?s=n.out&&n.out[t]:s=n.undirected&&n.undirected[t]),s}function pr(i){return i!==null&&typeof i=="object"&&typeof i.addUndirectedEdgeWithKey=="function"&&typeof i.dropNode=="function"}function Y(i){return typeof i=="object"&&i!==null&&i.constructor===Object}function xt(i){let e;for(e in i)return!1;return!0}function ne(i,e,t){Object.defineProperty(i,e,{enumerable:!1,configurable:!1,writable:!0,value:t})}function ue(i,e,t){const r={enumerable:!0,configurable:!0};typeof t=="function"?r.get=t:(r.value=t,r.writable=!1),Object.defineProperty(i,e,r)}function At(i){return!(!Y(i)||i.attributes&&!Array.isArray(i.attributes))}function gr(){let i=Math.floor(Math.random()*256)&255;return()=>i++}class Je extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}class w extends Je{constructor(e){super(e),this.name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,w.prototype.constructor)}}class y extends Je{constructor(e){super(e),this.name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,y.prototype.constructor)}}class E extends Je{constructor(e){super(e),this.name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,E.prototype.constructor)}}function Gt(i,e){this.key=i,this.attributes=e,this.clear()}Gt.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.in={},this.out={},this.undirected={}};function Dt(i,e){this.key=i,this.attributes=e,this.clear()}Dt.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.in={},this.out={}};function St(i,e){this.key=i,this.attributes=e,this.clear()}St.prototype.clear=function(){this.undirectedDegree=0,this.undirected={}};function De(i,e,t,r,n){this.key=e,this.attributes=n,this.undirected=i,this.source=t,this.target=r}De.prototype.attach=function(){let i="out",e="in";this.undirected&&(i=e="undirected");const t=this.source.key,r=this.target.key;this.source[i][r]=this,!(this.undirected&&t===r)&&(this.target[e][t]=this)},De.prototype.attachMulti=function(){let i="out",e="in";const t=this.source.key,r=this.target.key;this.undirected&&(i=e="undirected");const n=this.source[i],s=n[r];if(typeof s>"u"){n[r]=this,this.undirected&&t===r||(this.target[e][t]=this);return}s.previous=this,this.next=s,n[r]=this,this.target[e][t]=this},De.prototype.detach=function(){const i=this.source.key,e=this.target.key;let t="out",r="in";this.undirected&&(t=r="undirected"),delete this.source[t][e],delete this.target[r][i]},De.prototype.detachMulti=function(){const i=this.source.key,e=this.target.key;let t="out",r="in";this.undirected&&(t=r="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[t][e],delete this.target[r][i]):(this.next.previous=void 0,this.source[t][e]=this.next,this.target[r][i]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};const Ct=0,Lt=1,yr=2,Nt=3;function ye(i,e,t,r,n,s,o){let a,u,d,l;if(r=""+r,t===Ct){if(a=i._nodes.get(r),!a)throw new y(`Graph.${e}: could not find the "${r}" node in the graph.`);d=n,l=s}else if(t===Nt){if(n=""+n,u=i._edges.get(n),!u)throw new y(`Graph.${e}: could not find the "${n}" edge in the graph.`);const f=u.source.key,p=u.target.key;if(r===f)a=u.target;else if(r===p)a=u.source;else throw new y(`Graph.${e}: the "${r}" node is not attached to the "${n}" edge (${f}, ${p}).`);d=s,l=o}else{if(u=i._edges.get(r),!u)throw new y(`Graph.${e}: could not find the "${r}" edge in the graph.`);t===Lt?a=u.source:a=u.target,d=n,l=s}return[a,d,l]}function wr(i,e,t){i.prototype[e]=function(r,n,s){const[o,a]=ye(this,e,t,r,n,s);return o.attributes[a]}}function mr(i,e,t){i.prototype[e]=function(r,n){const[s]=ye(this,e,t,r,n);return s.attributes}}function br(i,e,t){i.prototype[e]=function(r,n,s){const[o,a]=ye(this,e,t,r,n,s);return o.attributes.hasOwnProperty(a)}}function _r(i,e,t){i.prototype[e]=function(r,n,s,o){const[a,u,d]=ye(this,e,t,r,n,s,o);return a.attributes[u]=d,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:u}),this}}function vr(i,e,t){i.prototype[e]=function(r,n,s,o){const[a,u,d]=ye(this,e,t,r,n,s,o);if(typeof d!="function")throw new w(`Graph.${e}: updater should be a function.`);const l=a.attributes,f=d(l[u]);return l[u]=f,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:u}),this}}function Er(i,e,t){i.prototype[e]=function(r,n,s){const[o,a]=ye(this,e,t,r,n,s);return delete o.attributes[a],this.emit("nodeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:a}),this}}function kr(i,e,t){i.prototype[e]=function(r,n,s){const[o,a]=ye(this,e,t,r,n,s);if(!Y(a))throw new w(`Graph.${e}: provided attributes are not a plain object.`);return o.attributes=a,this.emit("nodeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}function $r(i,e,t){i.prototype[e]=function(r,n,s){const[o,a]=ye(this,e,t,r,n,s);if(!Y(a))throw new w(`Graph.${e}: provided attributes are not a plain object.`);return K(o.attributes,a),this.emit("nodeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:a}),this}}function xr(i,e,t){i.prototype[e]=function(r,n,s){const[o,a]=ye(this,e,t,r,n,s);if(typeof a!="function")throw new w(`Graph.${e}: provided updater is not a function.`);return o.attributes=a(o.attributes),this.emit("nodeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}const Ar=[{name:i=>`get${i}Attribute`,attacher:wr},{name:i=>`get${i}Attributes`,attacher:mr},{name:i=>`has${i}Attribute`,attacher:br},{name:i=>`set${i}Attribute`,attacher:_r},{name:i=>`update${i}Attribute`,attacher:vr},{name:i=>`remove${i}Attribute`,attacher:Er},{name:i=>`replace${i}Attributes`,attacher:kr},{name:i=>`merge${i}Attributes`,attacher:$r},{name:i=>`update${i}Attributes`,attacher:xr}];function Gr(i){Ar.forEach(function({name:e,attacher:t}){t(i,e("Node"),Ct),t(i,e("Source"),Lt),t(i,e("Target"),yr),t(i,e("Opposite"),Nt)})}function Dr(i,e,t){i.prototype[e]=function(r,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new E(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new E(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+r,a=""+n;if(n=arguments[2],s=ie(this,o,a,t),!s)throw new y(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new E(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new y(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return s.attributes[n]}}function Sr(i,e,t){i.prototype[e]=function(r){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new E(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new E(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,o=""+arguments[1];if(n=ie(this,s,o,t),!n)throw new y(`Graph.${e}: could not find an edge for the given path ("${s}" - "${o}").`)}else{if(t!=="mixed")throw new E(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new y(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return n.attributes}}function Cr(i,e,t){i.prototype[e]=function(r,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new E(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new E(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+r,a=""+n;if(n=arguments[2],s=ie(this,o,a,t),!s)throw new y(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new E(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new y(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return s.attributes.hasOwnProperty(n)}}function Lr(i,e,t){i.prototype[e]=function(r,n,s){let o;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new E(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new E(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+r,u=""+n;if(n=arguments[2],s=arguments[3],o=ie(this,a,u,t),!o)throw new y(`Graph.${e}: could not find an edge for the given path ("${a}" - "${u}").`)}else{if(t!=="mixed")throw new E(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,o=this._edges.get(r),!o)throw new y(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return o.attributes[n]=s,this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:n}),this}}function Nr(i,e,t){i.prototype[e]=function(r,n,s){let o;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new E(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new E(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+r,u=""+n;if(n=arguments[2],s=arguments[3],o=ie(this,a,u,t),!o)throw new y(`Graph.${e}: could not find an edge for the given path ("${a}" - "${u}").`)}else{if(t!=="mixed")throw new E(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,o=this._edges.get(r),!o)throw new y(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(typeof s!="function")throw new w(`Graph.${e}: updater should be a function.`);return o.attributes[n]=s(o.attributes[n]),this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:n}),this}}function Rr(i,e,t){i.prototype[e]=function(r,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new E(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new E(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+r,a=""+n;if(n=arguments[2],s=ie(this,o,a,t),!s)throw new y(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new E(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new y(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return delete s.attributes[n],this.emit("edgeAttributesUpdated",{key:s.key,type:"remove",attributes:s.attributes,name:n}),this}}function Ir(i,e,t){i.prototype[e]=function(r,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new E(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new E(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+r,a=""+n;if(n=arguments[2],s=ie(this,o,a,t),!s)throw new y(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new E(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new y(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(!Y(n))throw new w(`Graph.${e}: provided attributes are not a plain object.`);return s.attributes=n,this.emit("edgeAttributesUpdated",{key:s.key,type:"replace",attributes:s.attributes}),this}}function Or(i,e,t){i.prototype[e]=function(r,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new E(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new E(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+r,a=""+n;if(n=arguments[2],s=ie(this,o,a,t),!s)throw new y(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new E(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new y(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(!Y(n))throw new w(`Graph.${e}: provided attributes are not a plain object.`);return K(s.attributes,n),this.emit("edgeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:n}),this}}function Ur(i,e,t){i.prototype[e]=function(r,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new E(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new E(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+r,a=""+n;if(n=arguments[2],s=ie(this,o,a,t),!s)throw new y(`Graph.${e}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if(t!=="mixed")throw new E(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new y(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(typeof n!="function")throw new w(`Graph.${e}: provided updater is not a function.`);return s.attributes=n(s.attributes),this.emit("edgeAttributesUpdated",{key:s.key,type:"update",attributes:s.attributes}),this}}const Tr=[{name:i=>`get${i}Attribute`,attacher:Dr},{name:i=>`get${i}Attributes`,attacher:Sr},{name:i=>`has${i}Attribute`,attacher:Cr},{name:i=>`set${i}Attribute`,attacher:Lr},{name:i=>`update${i}Attribute`,attacher:Nr},{name:i=>`remove${i}Attribute`,attacher:Rr},{name:i=>`replace${i}Attributes`,attacher:Ir},{name:i=>`merge${i}Attributes`,attacher:Or},{name:i=>`update${i}Attributes`,attacher:Ur}];function Mr(i){Tr.forEach(function({name:e,attacher:t}){t(i,e("Edge"),"mixed"),t(i,e("DirectedEdge"),"directed"),t(i,e("UndirectedEdge"),"undirected")})}const zr=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function jr(i,e,t,r){let n=!1;for(const s in e){if(s===r)continue;const o=e[s];if(n=t(o.key,o.attributes,o.source.key,o.target.key,o.source.attributes,o.target.attributes,o.undirected),i&&n)return o.key}}function Pr(i,e,t,r){let n,s,o,a=!1;for(const u in e)if(u!==r){n=e[u];do{if(s=n.source,o=n.target,a=t(n.key,n.attributes,s.key,o.key,s.attributes,o.attributes,n.undirected),i&&a)return n.key;n=n.next}while(n!==void 0)}}function Ze(i,e){const t=Object.keys(i),r=t.length;let n,s=0;return new re(function(){do if(n)n=n.next;else{if(s>=r)return{done:!0};const a=t[s++];if(a===e){n=void 0;continue}n=i[a]}while(!n);return{done:!1,value:{edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected}}})}function Fr(i,e,t,r){const n=e[t];if(!n)return;const s=n.source,o=n.target;if(r(n.key,n.attributes,s.key,o.key,s.attributes,o.attributes,n.undirected)&&i)return n.key}function Wr(i,e,t,r){let n=e[t];if(!n)return;let s=!1;do{if(s=r(n.key,n.attributes,n.source.key,n.target.key,n.source.attributes,n.target.attributes,n.undirected),i&&s)return n.key;n=n.next}while(n!==void 0)}function Xe(i,e){let t=i[e];return t.next!==void 0?new re(function(){if(!t)return{done:!0};const r={edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected};return t=t.next,{done:!1,value:r}}):re.of({edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected})}function Kr(i,e){if(i.size===0)return[];if(e==="mixed"||e===i.type)return typeof Array.from=="function"?Array.from(i._edges.keys()):$t(i._edges.keys(),i._edges.size);const t=e==="undirected"?i.undirectedSize:i.directedSize,r=new Array(t),n=e==="undirected",s=i._edges.values();let o=0,a,u;for(;a=s.next(),a.done!==!0;)u=a.value,u.undirected===n&&(r[o++]=u.key);return r}function Rt(i,e,t,r){if(e.size===0)return;const n=t!=="mixed"&&t!==e.type,s=t==="undirected";let o,a,u=!1;const d=e._edges.values();for(;o=d.next(),o.done!==!0;){if(a=o.value,n&&a.undirected!==s)continue;const{key:l,attributes:f,source:p,target:$}=a;if(u=r(l,f,p.key,$.key,p.attributes,$.attributes,a.undirected),i&&u)return l}}function qr(i,e){if(i.size===0)return re.empty();const t=e!=="mixed"&&e!==i.type,r=e==="undirected",n=i._edges.values();return new re(function(){let o,a;for(;;){if(o=n.next(),o.done)return o;if(a=o.value,!(t&&a.undirected!==r))break}return{value:{edge:a.key,attributes:a.attributes,source:a.source.key,target:a.target.key,sourceAttributes:a.source.attributes,targetAttributes:a.target.attributes,undirected:a.undirected},done:!1}})}function et(i,e,t,r,n,s){const o=e?Pr:jr;let a;if(t!=="undirected"&&(r!=="out"&&(a=o(i,n.in,s),i&&a)||r!=="in"&&(a=o(i,n.out,s,r?void 0:n.key),i&&a))||t!=="directed"&&(a=o(i,n.undirected,s),i&&a))return a}function Br(i,e,t,r){const n=[];return et(!1,i,e,t,r,function(s){n.push(s)}),n}function Hr(i,e,t){let r=re.empty();return i!=="undirected"&&(e!=="out"&&typeof t.in<"u"&&(r=ge(r,Ze(t.in))),e!=="in"&&typeof t.out<"u"&&(r=ge(r,Ze(t.out,e?void 0:t.key)))),i!=="directed"&&typeof t.undirected<"u"&&(r=ge(r,Ze(t.undirected))),r}function tt(i,e,t,r,n,s,o){const a=t?Wr:Fr;let u;if(e!=="undirected"&&(typeof n.in<"u"&&r!=="out"&&(u=a(i,n.in,s,o),i&&u)||typeof n.out<"u"&&r!=="in"&&(r||n.key!==s)&&(u=a(i,n.out,s,o),i&&u))||e!=="directed"&&typeof n.undirected<"u"&&(u=a(i,n.undirected,s,o),i&&u))return u}function Yr(i,e,t,r,n){const s=[];return tt(!1,i,e,t,r,n,function(o){s.push(o)}),s}function Vr(i,e,t,r){let n=re.empty();return i!=="undirected"&&(typeof t.in<"u"&&e!=="out"&&r in t.in&&(n=ge(n,Xe(t.in,r))),typeof t.out<"u"&&e!=="in"&&r in t.out&&(e||t.key!==r)&&(n=ge(n,Xe(t.out,r)))),i!=="directed"&&typeof t.undirected<"u"&&r in t.undirected&&(n=ge(n,Xe(t.undirected,r))),n}function Qr(i,e){const{name:t,type:r,direction:n}=e;i.prototype[t]=function(s,o){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return[];if(!arguments.length)return Kr(this,r);if(arguments.length===1){s=""+s;const a=this._nodes.get(s);if(typeof a>"u")throw new y(`Graph.${t}: could not find the "${s}" node in the graph.`);return Br(this.multi,r==="mixed"?this.type:r,n,a)}if(arguments.length===2){s=""+s,o=""+o;const a=this._nodes.get(s);if(!a)throw new y(`Graph.${t}:  could not find the "${s}" source node in the graph.`);if(!this._nodes.has(o))throw new y(`Graph.${t}:  could not find the "${o}" target node in the graph.`);return Yr(r,this.multi,n,a,o)}throw new w(`Graph.${t}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Jr(i,e){const{name:t,type:r,direction:n}=e,s="forEach"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(d,l,f){if(!(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)){if(arguments.length===1)return f=d,Rt(!1,this,r,f);if(arguments.length===2){d=""+d,f=l;const p=this._nodes.get(d);if(typeof p>"u")throw new y(`Graph.${s}: could not find the "${d}" node in the graph.`);return et(!1,this.multi,r==="mixed"?this.type:r,n,p,f)}if(arguments.length===3){d=""+d,l=""+l;const p=this._nodes.get(d);if(!p)throw new y(`Graph.${s}:  could not find the "${d}" source node in the graph.`);if(!this._nodes.has(l))throw new y(`Graph.${s}:  could not find the "${l}" target node in the graph.`);return tt(!1,r,this.multi,n,p,l,f)}throw new w(`Graph.${s}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const o="map"+t[0].toUpperCase()+t.slice(1);i.prototype[o]=function(){const d=Array.prototype.slice.call(arguments),l=d.pop();let f;if(d.length===0){let p=0;r!=="directed"&&(p+=this.undirectedSize),r!=="undirected"&&(p+=this.directedSize),f=new Array(p);let $=0;d.push((R,V,P,q,se,be,Pe)=>{f[$++]=l(R,V,P,q,se,be,Pe)})}else f=[],d.push((p,$,R,V,P,q,se)=>{f.push(l(p,$,R,V,P,q,se))});return this[s].apply(this,d),f};const a="filter"+t[0].toUpperCase()+t.slice(1);i.prototype[a]=function(){const d=Array.prototype.slice.call(arguments),l=d.pop(),f=[];return d.push((p,$,R,V,P,q,se)=>{l(p,$,R,V,P,q,se)&&f.push(p)}),this[s].apply(this,d),f};const u="reduce"+t[0].toUpperCase()+t.slice(1);i.prototype[u]=function(){let d=Array.prototype.slice.call(arguments);if(d.length<2||d.length>4)throw new w(`Graph.${u}: invalid number of arguments (expecting 2, 3 or 4 and got ${d.length}).`);if(typeof d[d.length-1]=="function"&&typeof d[d.length-2]!="function")throw new w(`Graph.${u}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let l,f;d.length===2?(l=d[0],f=d[1],d=[]):d.length===3?(l=d[1],f=d[2],d=[d[0]]):d.length===4&&(l=d[2],f=d[3],d=[d[0],d[1]]);let p=f;return d.push(($,R,V,P,q,se,be)=>{p=l(p,$,R,V,P,q,se,be)}),this[s].apply(this,d),p}}function Zr(i,e){const{name:t,type:r,direction:n}=e,s="find"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(u,d,l){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return!1;if(arguments.length===1)return l=u,Rt(!0,this,r,l);if(arguments.length===2){u=""+u,l=d;const f=this._nodes.get(u);if(typeof f>"u")throw new y(`Graph.${s}: could not find the "${u}" node in the graph.`);return et(!0,this.multi,r==="mixed"?this.type:r,n,f,l)}if(arguments.length===3){u=""+u,d=""+d;const f=this._nodes.get(u);if(!f)throw new y(`Graph.${s}:  could not find the "${u}" source node in the graph.`);if(!this._nodes.has(d))throw new y(`Graph.${s}:  could not find the "${d}" target node in the graph.`);return tt(!0,r,this.multi,n,f,d,l)}throw new w(`Graph.${s}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const o="some"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[o]=function(){const u=Array.prototype.slice.call(arguments),d=u.pop();return u.push((f,p,$,R,V,P,q)=>d(f,p,$,R,V,P,q)),!!this[s].apply(this,u)};const a="every"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[a]=function(){const u=Array.prototype.slice.call(arguments),d=u.pop();return u.push((f,p,$,R,V,P,q)=>!d(f,p,$,R,V,P,q)),!this[s].apply(this,u)}}function Xr(i,e){const{name:t,type:r,direction:n}=e,s=t.slice(0,-1)+"Entries";i.prototype[s]=function(o,a){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return re.empty();if(!arguments.length)return qr(this,r);if(arguments.length===1){o=""+o;const u=this._nodes.get(o);if(!u)throw new y(`Graph.${s}: could not find the "${o}" node in the graph.`);return Hr(r,n,u)}if(arguments.length===2){o=""+o,a=""+a;const u=this._nodes.get(o);if(!u)throw new y(`Graph.${s}:  could not find the "${o}" source node in the graph.`);if(!this._nodes.has(a))throw new y(`Graph.${s}:  could not find the "${a}" target node in the graph.`);return Vr(r,n,u,a)}throw new w(`Graph.${s}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function ei(i){zr.forEach(e=>{Qr(i,e),Jr(i,e),Zr(i,e),Xr(i,e)})}const ti=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function ze(){this.A=null,this.B=null}ze.prototype.wrap=function(i){this.A===null?this.A=i:this.B===null&&(this.B=i)},ze.prototype.has=function(i){return this.A!==null&&i in this.A||this.B!==null&&i in this.B};function Ne(i,e,t,r,n){for(const s in r){const o=r[s],a=o.source,u=o.target,d=a===t?u:a;if(e&&e.has(d.key))continue;const l=n(d.key,d.attributes);if(i&&l)return d.key}}function rt(i,e,t,r,n){if(e!=="mixed"){if(e==="undirected")return Ne(i,null,r,r.undirected,n);if(typeof t=="string")return Ne(i,null,r,r[t],n)}const s=new ze;let o;if(e!=="undirected"){if(t!=="out"){if(o=Ne(i,null,r,r.in,n),i&&o)return o;s.wrap(r.in)}if(t!=="in"){if(o=Ne(i,s,r,r.out,n),i&&o)return o;s.wrap(r.out)}}if(e!=="directed"&&(o=Ne(i,s,r,r.undirected,n),i&&o))return o}function ri(i,e,t){if(i!=="mixed"){if(i==="undirected")return Object.keys(t.undirected);if(typeof e=="string")return Object.keys(t[e])}const r=[];return rt(!1,i,e,t,function(n){r.push(n)}),r}function Re(i,e,t){const r=Object.keys(t),n=r.length;let s=0;return new re(function(){let a=null;do{if(s>=n)return i&&i.wrap(t),{done:!0};const u=t[r[s++]],d=u.source,l=u.target;if(a=d===e?l:d,i&&i.has(a.key)){a=null;continue}}while(a===null);return{done:!1,value:{neighbor:a.key,attributes:a.attributes}}})}function ii(i,e,t){if(i!=="mixed"){if(i==="undirected")return Re(null,t,t.undirected);if(typeof e=="string")return Re(null,t,t[e])}let r=re.empty();const n=new ze;return i!=="undirected"&&(e!=="out"&&(r=ge(r,Re(n,t,t.in))),e!=="in"&&(r=ge(r,Re(n,t,t.out)))),i!=="directed"&&(r=ge(r,Re(n,t,t.undirected))),r}function ni(i,e){const{name:t,type:r,direction:n}=e;i.prototype[t]=function(s){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return[];s=""+s;const o=this._nodes.get(s);if(typeof o>"u")throw new y(`Graph.${t}: could not find the "${s}" node in the graph.`);return ri(r==="mixed"?this.type:r,n,o)}}function si(i,e){const{name:t,type:r,direction:n}=e,s="forEach"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(d,l){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return;d=""+d;const f=this._nodes.get(d);if(typeof f>"u")throw new y(`Graph.${s}: could not find the "${d}" node in the graph.`);rt(!1,r==="mixed"?this.type:r,n,f,l)};const o="map"+t[0].toUpperCase()+t.slice(1);i.prototype[o]=function(d,l){const f=[];return this[s](d,(p,$)=>{f.push(l(p,$))}),f};const a="filter"+t[0].toUpperCase()+t.slice(1);i.prototype[a]=function(d,l){const f=[];return this[s](d,(p,$)=>{l(p,$)&&f.push(p)}),f};const u="reduce"+t[0].toUpperCase()+t.slice(1);i.prototype[u]=function(d,l,f){if(arguments.length<3)throw new w(`Graph.${u}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let p=f;return this[s](d,($,R)=>{p=l(p,$,R)}),p}}function oi(i,e){const{name:t,type:r,direction:n}=e,s=t[0].toUpperCase()+t.slice(1,-1),o="find"+s;i.prototype[o]=function(d,l){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return;d=""+d;const f=this._nodes.get(d);if(typeof f>"u")throw new y(`Graph.${o}: could not find the "${d}" node in the graph.`);return rt(!0,r==="mixed"?this.type:r,n,f,l)};const a="some"+s;i.prototype[a]=function(d,l){return!!this[o](d,l)};const u="every"+s;i.prototype[u]=function(d,l){return!this[o](d,(p,$)=>!l(p,$))}}function ai(i,e){const{name:t,type:r,direction:n}=e,s=t.slice(0,-1)+"Entries";i.prototype[s]=function(o){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return re.empty();o=""+o;const a=this._nodes.get(o);if(typeof a>"u")throw new y(`Graph.${s}: could not find the "${o}" node in the graph.`);return ii(r==="mixed"?this.type:r,n,a)}}function ui(i){ti.forEach(e=>{ni(i,e),si(i,e),oi(i,e),ai(i,e)})}function je(i,e,t,r,n){const s=r._nodes.values(),o=r.type;let a,u,d,l,f,p,$;for(;a=s.next(),a.done!==!0;){let R=!1;if(u=a.value,o!=="undirected"){l=u.out;for(d in l){f=l[d];do{if(p=f.target,R=!0,$=n(u.key,p.key,u.attributes,p.attributes,f.key,f.attributes,f.undirected),i&&$)return f;f=f.next}while(f)}}if(o!=="directed"){l=u.undirected;for(d in l)if(!(e&&u.key>d)){f=l[d];do{if(p=f.target,p.key!==d&&(p=f.source),R=!0,$=n(u.key,p.key,u.attributes,p.attributes,f.key,f.attributes,f.undirected),i&&$)return f;f=f.next}while(f)}}if(t&&!R&&($=n(u.key,null,u.attributes,null,null,null,null),i&&$))return null}}function hi(i,e){const t={key:i};return xt(e.attributes)||(t.attributes=K({},e.attributes)),t}function di(i,e){const t={key:i,source:e.source.key,target:e.target.key};return xt(e.attributes)||(t.attributes=K({},e.attributes)),e.undirected&&(t.undirected=!0),t}function ci(i){if(!Y(i))throw new w('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in i))throw new w("Graph.import: serialized node is missing its key.");if("attributes"in i&&(!Y(i.attributes)||i.attributes===null))throw new w("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function fi(i){if(!Y(i))throw new w('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in i))throw new w("Graph.import: serialized edge is missing its source.");if(!("target"in i))throw new w("Graph.import: serialized edge is missing its target.");if("attributes"in i&&(!Y(i.attributes)||i.attributes===null))throw new w("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in i&&typeof i.undirected!="boolean")throw new w("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}const li=gr(),pi=new Set(["directed","undirected","mixed"]),It=new Set(["domain","_events","_eventsCount","_maxListeners"]),gi=[{name:i=>`${i}Edge`,generateKey:!0},{name:i=>`${i}DirectedEdge`,generateKey:!0,type:"directed"},{name:i=>`${i}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:i=>`${i}EdgeWithKey`},{name:i=>`${i}DirectedEdgeWithKey`,type:"directed"},{name:i=>`${i}UndirectedEdgeWithKey`,type:"undirected"}],yi={allowSelfLoops:!0,multi:!1,type:"mixed"};function wi(i,e,t){if(t&&!Y(t))throw new w(`Graph.addNode: invalid attributes. Expecting an object but got "${t}"`);if(e=""+e,t=t||{},i._nodes.has(e))throw new E(`Graph.addNode: the "${e}" node already exist in the graph.`);const r=new i.NodeDataClass(e,t);return i._nodes.set(e,r),i.emit("nodeAdded",{key:e,attributes:t}),r}function Ot(i,e,t){const r=new i.NodeDataClass(e,t);return i._nodes.set(e,r),i.emit("nodeAdded",{key:e,attributes:t}),r}function Ut(i,e,t,r,n,s,o,a){if(!r&&i.type==="undirected")throw new E(`Graph.${e}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(r&&i.type==="directed")throw new E(`Graph.${e}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(a&&!Y(a))throw new w(`Graph.${e}: invalid attributes. Expecting an object but got "${a}"`);if(s=""+s,o=""+o,a=a||{},!i.allowSelfLoops&&s===o)throw new E(`Graph.${e}: source & target are the same ("${s}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const u=i._nodes.get(s),d=i._nodes.get(o);if(!u)throw new y(`Graph.${e}: source node "${s}" not found.`);if(!d)throw new y(`Graph.${e}: target node "${o}" not found.`);const l={key:null,undirected:r,source:s,target:o,attributes:a};if(t)n=i._edgeKeyGenerator();else if(n=""+n,i._edges.has(n))throw new E(`Graph.${e}: the "${n}" edge already exists in the graph.`);if(!i.multi&&(r?typeof u.undirected[o]<"u":typeof u.out[o]<"u"))throw new E(`Graph.${e}: an edge linking "${s}" to "${o}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const f=new De(r,n,u,d,a);i._edges.set(n,f);const p=s===o;return r?(u.undirectedDegree++,d.undirectedDegree++,p&&i._undirectedSelfLoopCount++):(u.outDegree++,d.inDegree++,p&&i._directedSelfLoopCount++),i.multi?f.attachMulti():f.attach(),r?i._undirectedSize++:i._directedSize++,l.key=n,i.emit("edgeAdded",l),n}function mi(i,e,t,r,n,s,o,a,u){if(!r&&i.type==="undirected")throw new E(`Graph.${e}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(r&&i.type==="directed")throw new E(`Graph.${e}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(a){if(u){if(typeof a!="function")throw new w(`Graph.${e}: invalid updater function. Expecting a function but got "${a}"`)}else if(!Y(a))throw new w(`Graph.${e}: invalid attributes. Expecting an object but got "${a}"`)}s=""+s,o=""+o;let d;if(u&&(d=a,a=void 0),!i.allowSelfLoops&&s===o)throw new E(`Graph.${e}: source & target are the same ("${s}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let l=i._nodes.get(s),f=i._nodes.get(o),p,$;if(!t&&(p=i._edges.get(n),p)){if((p.source.key!==s||p.target.key!==o)&&(!r||p.source.key!==o||p.target.key!==s))throw new E(`Graph.${e}: inconsistency detected when attempting to merge the "${n}" edge with "${s}" source & "${o}" target vs. ("${p.source.key}", "${p.target.key}").`);$=p}if(!$&&!i.multi&&l&&($=r?l.undirected[o]:l.out[o]),$){const se=[$.key,!1,!1,!1];if(u?!d:!a)return se;if(u){const be=$.attributes;$.attributes=d(be),i.emit("edgeAttributesUpdated",{type:"replace",key:$.key,attributes:$.attributes})}else K($.attributes,a),i.emit("edgeAttributesUpdated",{type:"merge",key:$.key,attributes:$.attributes,data:a});return se}a=a||{},u&&d&&(a=d(a));const R={key:null,undirected:r,source:s,target:o,attributes:a};if(t)n=i._edgeKeyGenerator();else if(n=""+n,i._edges.has(n))throw new E(`Graph.${e}: the "${n}" edge already exists in the graph.`);let V=!1,P=!1;l||(l=Ot(i,s,{}),V=!0,s===o&&(f=l,P=!0)),f||(f=Ot(i,o,{}),P=!0),p=new De(r,n,l,f,a),i._edges.set(n,p);const q=s===o;return r?(l.undirectedDegree++,f.undirectedDegree++,q&&i._undirectedSelfLoopCount++):(l.outDegree++,f.inDegree++,q&&i._directedSelfLoopCount++),i.multi?p.attachMulti():p.attach(),r?i._undirectedSize++:i._directedSize++,R.key=n,i.emit("edgeAdded",R),[n,!0,V,P]}function Se(i,e){i._edges.delete(e.key);const{source:t,target:r,attributes:n}=e,s=e.undirected,o=t===r;s?(t.undirectedDegree--,r.undirectedDegree--,o&&i._undirectedSelfLoopCount--):(t.outDegree--,r.inDegree--,o&&i._directedSelfLoopCount--),i.multi?e.detachMulti():e.detach(),s?i._undirectedSize--:i._directedSize--,i.emit("edgeDropped",{key:e.key,attributes:n,source:t.key,target:r.key,undirected:s})}class I extends ir.EventEmitter{constructor(e){if(super(),e=K({},yi,e),typeof e.multi!="boolean")throw new w(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!pi.has(e.type))throw new w(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if(typeof e.allowSelfLoops!="boolean")throw new w(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);const t=e.type==="mixed"?Gt:e.type==="directed"?Dt:St;ne(this,"NodeDataClass",t);const r="geid_"+li()+"_";let n=0;const s=()=>{let o;do o=r+n++;while(this._edges.has(o));return o};ne(this,"_attributes",{}),ne(this,"_nodes",new Map),ne(this,"_edges",new Map),ne(this,"_directedSize",0),ne(this,"_undirectedSize",0),ne(this,"_directedSelfLoopCount",0),ne(this,"_undirectedSelfLoopCount",0),ne(this,"_edgeKeyGenerator",s),ne(this,"_options",e),It.forEach(o=>ne(this,o,this[o])),ue(this,"order",()=>this._nodes.size),ue(this,"size",()=>this._edges.size),ue(this,"directedSize",()=>this._directedSize),ue(this,"undirectedSize",()=>this._undirectedSize),ue(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),ue(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),ue(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),ue(this,"multi",this._options.multi),ue(this,"type",this._options.type),ue(this,"allowSelfLoops",this._options.allowSelfLoops),ue(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if(this.type==="undirected")return!1;if(arguments.length===1){const r=""+e,n=this._edges.get(r);return!!n&&!n.undirected}else if(arguments.length===2){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)return!1;const n=r.out[t];return n?this.multi?!!n.size:!0:!1}throw new w(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(e,t){if(this.type==="directed")return!1;if(arguments.length===1){const r=""+e,n=this._edges.get(r);return!!n&&n.undirected}else if(arguments.length===2){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)return!1;const n=r.undirected[t];return n?this.multi?!!n.size:!0:!1}throw new w(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(e,t){if(arguments.length===1){const r=""+e;return this._edges.has(r)}else if(arguments.length===2){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)return!1;let n=typeof r.out<"u"&&r.out[t];return n||(n=typeof r.undirected<"u"&&r.undirected[t]),n?this.multi?!!n.size:!0:!1}throw new w(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(e,t){if(this.type==="undirected")return;if(e=""+e,t=""+t,this.multi)throw new E("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const r=this._nodes.get(e);if(!r)throw new y(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new y(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);const n=r.out&&r.out[t]||void 0;if(n)return n.key}undirectedEdge(e,t){if(this.type==="directed")return;if(e=""+e,t=""+t,this.multi)throw new E("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const r=this._nodes.get(e);if(!r)throw new y(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new y(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);const n=r.undirected&&r.undirected[t]||void 0;if(n)return n.key}edge(e,t){if(this.multi)throw new E("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new y(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new y(`Graph.edge: could not find the "${t}" target node in the graph.`);const n=r.out&&r.out[t]||r.undirected&&r.undirected[t]||void 0;if(n)return n.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new y(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in r.in||t in r.out}areOutNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new y(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in r.out}areInNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new y(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in r.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new y(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return this.type==="directed"?!1:t in r.undirected}areNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new y(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&(t in r.in||t in r.out)||this.type!=="directed"&&t in r.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new y(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&t in r.in||this.type!=="directed"&&t in r.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new y(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&t in r.out||this.type!=="directed"&&t in r.undirected}inDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.inDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree}outDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.outDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.outDegree}directedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return this.type==="directed"?0:t.undirectedDegree}inboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let r=0;return this.type!=="directed"&&(r+=t.undirectedDegree),this.type!=="undirected"&&(r+=t.inDegree),r}outboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let r=0;return this.type!=="directed"&&(r+=t.undirectedDegree),this.type!=="undirected"&&(r+=t.outDegree),r}degree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.degree: could not find the "${e}" node in the graph.`);let r=0;return this.type!=="directed"&&(r+=t.undirectedDegree),this.type!=="undirected"&&(r+=t.inDegree+t.outDegree),r}inDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);if(this.type==="undirected")return 0;const r=t.in[e],n=r?this.multi?r.size:1:0;return t.inDegree-n}outDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);if(this.type==="undirected")return 0;const r=t.out[e],n=r?this.multi?r.size:1:0;return t.outDegree-n}directedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);if(this.type==="undirected")return 0;const r=t.out[e],n=r?this.multi?r.size:1:0;return t.inDegree+t.outDegree-n*2}undirectedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);if(this.type==="directed")return 0;const r=t.undirected[e],n=r?this.multi?r.size:1:0;return t.undirectedDegree-n*2}inboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r,n=0,s=0;return this.type!=="directed"&&(n+=t.undirectedDegree,r=t.undirected[e],s+=(r?this.multi?r.size:1:0)*2),this.type!=="undirected"&&(n+=t.inDegree,r=t.out[e],s+=r?this.multi?r.size:1:0),n-s}outboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r,n=0,s=0;return this.type!=="directed"&&(n+=t.undirectedDegree,r=t.undirected[e],s+=(r?this.multi?r.size:1:0)*2),this.type!=="undirected"&&(n+=t.outDegree,r=t.in[e],s+=r?this.multi?r.size:1:0),n-s}degreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r,n=0,s=0;return this.type!=="directed"&&(n+=t.undirectedDegree,r=t.undirected[e],s+=(r?this.multi?r.size:1:0)*2),this.type!=="undirected"&&(n+=t.inDegree+t.outDegree,r=t.out[e],s+=(r?this.multi?r.size:1:0)*2),n-s}source(e){e=""+e;const t=this._edges.get(e);if(!t)throw new y(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){e=""+e;const t=this._edges.get(e);if(!t)throw new y(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){e=""+e;const t=this._edges.get(e);if(!t)throw new y(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;const r=this._edges.get(t);if(!r)throw new y(`Graph.opposite: could not find the "${t}" edge in the graph.`);const n=r.source.key,s=r.target.key;if(e===n)return s;if(e===s)return n;throw new y(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${n}, ${s}).`)}hasExtremity(e,t){e=""+e,t=""+t;const r=this._edges.get(e);if(!r)throw new y(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return r.source.key===t||r.target.key===t}isUndirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new y(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new y(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){e=""+e;const t=this._edges.get(e);if(!t)throw new y(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){return wi(this,e,t).key}mergeNode(e,t){if(t&&!Y(t))throw new w(`Graph.mergeNode: invalid attributes. Expecting an object but got "${t}"`);e=""+e,t=t||{};let r=this._nodes.get(e);return r?(t&&(K(r.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:r.attributes,data:t})),[e,!1]):(r=new this.NodeDataClass(e,t),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&typeof t!="function")throw new w(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);e=""+e;let r=this._nodes.get(e);if(r){if(t){const s=r.attributes;r.attributes=t(s),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:r.attributes})}return[e,!1]}const n=t?t({}):{};return r=new this.NodeDataClass(e,n),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:n}),[e,!0]}dropNode(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new y(`Graph.dropNode: could not find the "${e}" node in the graph.`);let r;if(this.type!=="undirected"){for(const n in t.out){r=t.out[n];do Se(this,r),r=r.next;while(r)}for(const n in t.in){r=t.in[n];do Se(this,r),r=r.next;while(r)}}if(this.type!=="directed")for(const n in t.undirected){r=t.undirected[n];do Se(this,r),r=r.next;while(r)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:t.attributes})}dropEdge(e){let t;if(arguments.length>1){const r=""+arguments[0],n=""+arguments[1];if(t=ie(this,r,n,this.type),!t)throw new y(`Graph.dropEdge: could not find the "${r}" -> "${n}" edge in the graph.`)}else if(e=""+e,t=this._edges.get(e),!t)throw new y(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return Se(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new E("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new E("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");e=""+e,t=""+t;const r=ie(this,e,t,"directed");if(!r)throw new y(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return Se(this,r),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new E("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new E("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const r=ie(this,e,t,"undirected");if(!r)throw new y(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return Se(this,r),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const e=this._nodes.values();let t;for(;t=e.next(),t.done!==!0;)t.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if(typeof t!="function")throw new w("Graph.updateAttribute: updater should be a function.");const r=this._attributes[e];return this._attributes[e]=t(r),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!Y(e))throw new w("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!Y(e))throw new w("Graph.mergeAttributes: provided attributes are not a plain object.");return K(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if(typeof e!="function")throw new w("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){if(typeof e!="function")throw new w("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!At(t))throw new w("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const r=this._nodes.values();let n,s;for(;n=r.next(),n.done!==!0;)s=n.value,s.attributes=e(s.key,s.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){if(typeof e!="function")throw new w("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!At(t))throw new w("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const r=this._edges.values();let n,s,o,a;for(;n=r.next(),n.done!==!0;)s=n.value,o=s.source,a=s.target,s.attributes=e(s.key,s.attributes,o.key,a.key,o.attributes,a.attributes,s.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if(typeof e!="function")throw new w("Graph.forEachAdjacencyEntry: expecting a callback.");je(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if(typeof e!="function")throw new w("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");je(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if(typeof e!="function")throw new w("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");je(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if(typeof e!="function")throw new w("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");je(!1,!0,!0,this,e)}nodes(){return typeof Array.from=="function"?Array.from(this._nodes.keys()):$t(this._nodes.keys(),this._nodes.size)}forEachNode(e){if(typeof e!="function")throw new w("Graph.forEachNode: expecting a callback.");const t=this._nodes.values();let r,n;for(;r=t.next(),r.done!==!0;)n=r.value,e(n.key,n.attributes)}findNode(e){if(typeof e!="function")throw new w("Graph.findNode: expecting a callback.");const t=this._nodes.values();let r,n;for(;r=t.next(),r.done!==!0;)if(n=r.value,e(n.key,n.attributes))return n.key}mapNodes(e){if(typeof e!="function")throw new w("Graph.mapNode: expecting a callback.");const t=this._nodes.values();let r,n;const s=new Array(this.order);let o=0;for(;r=t.next(),r.done!==!0;)n=r.value,s[o++]=e(n.key,n.attributes);return s}someNode(e){if(typeof e!="function")throw new w("Graph.someNode: expecting a callback.");const t=this._nodes.values();let r,n;for(;r=t.next(),r.done!==!0;)if(n=r.value,e(n.key,n.attributes))return!0;return!1}everyNode(e){if(typeof e!="function")throw new w("Graph.everyNode: expecting a callback.");const t=this._nodes.values();let r,n;for(;r=t.next(),r.done!==!0;)if(n=r.value,!e(n.key,n.attributes))return!1;return!0}filterNodes(e){if(typeof e!="function")throw new w("Graph.filterNodes: expecting a callback.");const t=this._nodes.values();let r,n;const s=[];for(;r=t.next(),r.done!==!0;)n=r.value,e(n.key,n.attributes)&&s.push(n.key);return s}reduceNodes(e,t){if(typeof e!="function")throw new w("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new w("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let r=t;const n=this._nodes.values();let s,o;for(;s=n.next(),s.done!==!0;)o=s.value,r=e(r,o.key,o.attributes);return r}nodeEntries(){const e=this._nodes.values();return new re(()=>{const t=e.next();if(t.done)return t;const r=t.value;return{value:{node:r.key,attributes:r.attributes},done:!1}})}export(){const e=new Array(this._nodes.size);let t=0;this._nodes.forEach((n,s)=>{e[t++]=hi(s,n)});const r=new Array(this._edges.size);return t=0,this._edges.forEach((n,s)=>{r[t++]=di(s,n)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:r}}import(e,t=!1){if(pr(e))return e.forEachNode((u,d)=>{t?this.mergeNode(u,d):this.addNode(u,d)}),e.forEachEdge((u,d,l,f,p,$,R)=>{t?R?this.mergeUndirectedEdgeWithKey(u,l,f,d):this.mergeDirectedEdgeWithKey(u,l,f,d):R?this.addUndirectedEdgeWithKey(u,l,f,d):this.addDirectedEdgeWithKey(u,l,f,d)}),this;if(!Y(e))throw new w("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!Y(e.attributes))throw new w("Graph.import: invalid attributes. Expecting a plain object.");t?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}let r,n,s,o,a;if(e.nodes){if(s=e.nodes,!Array.isArray(s))throw new w("Graph.import: invalid nodes. Expecting an array.");for(r=0,n=s.length;r<n;r++){o=s[r],ci(o);const{key:u,attributes:d}=o;t?this.mergeNode(u,d):this.addNode(u,d)}}if(e.edges){if(s=e.edges,!Array.isArray(s))throw new w("Graph.import: invalid edges. Expecting an array.");for(r=0,n=s.length;r<n;r++){a=s[r],fi(a);const{source:u,target:d,attributes:l,undirected:f=!1}=a;let p;"key"in a?(p=t?f?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:f?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,p.call(this,a.key,u,d,l)):(p=t?f?this.mergeUndirectedEdge:this.mergeDirectedEdge:f?this.addUndirectedEdge:this.addDirectedEdge,p.call(this,u,d,l))}}return this}nullCopy(e){const t=new I(K({},this._options,e));return t.replaceAttributes(K({},this.getAttributes())),t}emptyCopy(e){const t=this.nullCopy(e);return this._nodes.forEach((r,n)=>{const s=K({},r.attributes);r=new t.NodeDataClass(n,s),t._nodes.set(n,r)}),t}copy(e){if(e=e||{},typeof e.type=="string"&&e.type!==this.type&&e.type!=="mixed")throw new E(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if(typeof e.multi=="boolean"&&e.multi!==this.multi&&e.multi!==!0)throw new E("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof e.allowSelfLoops=="boolean"&&e.allowSelfLoops!==this.allowSelfLoops&&e.allowSelfLoops!==!0)throw new E("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const t=this.emptyCopy(e),r=this._edges.values();let n,s;for(;n=r.next(),n.done!==!0;)s=n.value,Ut(t,"copy",!1,s.undirected,s.key,s.source.key,s.target.key,K({},s.attributes));return t}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const e={};this._nodes.forEach((s,o)=>{e[o]=s.attributes});const t={},r={};this._edges.forEach((s,o)=>{const a=s.undirected?"--":"->";let u="",d=s.source.key,l=s.target.key,f;s.undirected&&d>l&&(f=d,d=l,l=f);const p=`(${d})${a}(${l})`;o.startsWith("geid_")?this.multi&&(typeof r[p]>"u"?r[p]=0:r[p]++,u+=`${r[p]}. `):u+=`[${o}]: `,u+=p,t[u]=s.attributes});const n={};for(const s in this)this.hasOwnProperty(s)&&!It.has(s)&&typeof this[s]!="function"&&typeof s!="symbol"&&(n[s]=this[s]);return n.attributes=this._attributes,n.nodes=e,n.edges=t,ne(n,"constructor",this.constructor),n}}typeof Symbol<"u"&&(I.prototype[Symbol.for("nodejs.util.inspect.custom")]=I.prototype.inspect),gi.forEach(i=>{["add","merge","update"].forEach(e=>{const t=i.name(e),r=e==="add"?Ut:mi;i.generateKey?I.prototype[t]=function(n,s,o){return r(this,t,!0,(i.type||this.type)==="undirected",null,n,s,o,e==="update")}:I.prototype[t]=function(n,s,o,a){return r(this,t,!1,(i.type||this.type)==="undirected",n,s,o,a,e==="update")}})}),Gr(I),Mr(I),ei(I),ui(I);class it extends I{constructor(e){const t=K({type:"directed"},e);if("multi"in t&&t.multi!==!1)throw new w("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="directed")throw new w('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class nt extends I{constructor(e){const t=K({type:"undirected"},e);if("multi"in t&&t.multi!==!1)throw new w("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="undirected")throw new w('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class Tt extends I{constructor(e){const t=K({multi:!0},e);if("multi"in t&&t.multi!==!0)throw new w("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(t)}}class Mt extends I{constructor(e){const t=K({type:"directed",multi:!0},e);if("multi"in t&&t.multi!==!0)throw new w("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(t.type!=="directed")throw new w('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class zt extends I{constructor(e){const t=K({type:"undirected",multi:!0},e);if("multi"in t&&t.multi!==!0)throw new w("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(t.type!=="undirected")throw new w('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}function Ce(i){i.from=function(e,t){const r=K({},e.options,t),n=new i(r);return n.import(e),n}}Ce(I),Ce(it),Ce(nt),Ce(Tt),Ce(Mt),Ce(zt),I.Graph=I,I.DirectedGraph=it,I.UndirectedGraph=nt,I.MultiGraph=Tt,I.MultiDirectedGraph=Mt,I.MultiUndirectedGraph=zt,I.InvalidArgumentsGraphError=w,I.NotFoundGraphError=y,I.UsageGraphError=E;class bi{constructor(e){le(this,"_table");le(this,"_header");le(this,"_parseError");le(this,"_numRows");const t=new TextDecoder().decode(e);if(t.match(/\ufffd/)){this._parseError="Input file appears to be binary";return}let r;const n=Qt.parse(t,{skipEmptyLines:!0});if(n.errors.length>0){this._parseError="DSV Parsing Error: "+[...new Set(n.errors.map(o=>o.code))].join("; ")+" (check that input is in DSV format)";return}else if(n.meta.truncated){this._parseError="DSV Parsing Error: Result was truncated";return}else if(n.meta.aborted){this._parseError="DSV Parsing Error: Result was aborted";return}else r=n.data;if(r.length<2){this._parseError="DSV is empty (contains zero or one rows)";return}for(let o=0;o<r.length;o++)for(let a=0;a<r[o].length;a++)r[o][a]=r[o][a].trim();if(new Set(r[0]).size!=r[0].length){this._parseError=`The header cannot contain duplicates values: ${r[0]}`;return}let s=-1;for(let o=0;o<r.length;o++)if(r[o].length<2){this._parseError=`DSV Parsing Error: Each row much have at least 2 fields, found ${r[o].length}: ${r[o]}`;return}else if(s>=0&&r[o].length!=s){this._parseError="DSV Parsing Error: The number of fields in all rows must be equal";return}else if(r[o].every(a=>a))s=r[o].length;else{this._parseError="DSV Parsing Error: There are empty fields";return}this._table=r.slice(1),this._header=r[0],this._numRows=r.length-1}header(){if(!this._header)throw new Error("Can't be here, header is undefined");return this._header.slice()}numRows(){if(!this._numRows)throw new Error("Can't be here, numRows is undefined");return this._numRows}parseError(){return this._parseError?this._parseError:null}determine(e,t){if(!this._table)throw new Error("Can't be here, table is undefined");let r=!0,n=!0;const s={};for(let o=1;o<this._table.length;o++){const a=this._table[o][e],u=this._table[o][t];if(a in s||(s[a]=new Set),u in s||(s[u]=new Set),s[a].has(u)){n=!1,r=!1;break}s[u].has(a)&&(n=!1),s[a].add(u)}return[r,n]}slice(e,t){if(!this._table)throw new Error("Can't be here, table is undefined");return this._table.slice(e,t)}import(e,t,r){if(!this._table)throw new Error("Can't be here, table is undefined");if(!this._header)throw new Error("Can't be here, header is undefined");const n=[...Array(this._header.length).keys()].filter(o=>o!=e&&o!=t),s=r?new it:new nt;for(let o=0;o<this._table.length;o++){const a=this._table[o][e],u=this._table[o][t];s.hasNode(a)||s.addNode(a),s.hasNode(u)||s.addNode(u);const d={};for(const l of n)d[this._header[l]]=this._table[o][l];s.addEdge(a,u,d)}return s}}class _i{constructor(){le(this,"queue");le(this,"graphs");le(this,"csvImporter");le(this,"csvImporterIndex");le(this,"graphChangedCallback");this.queue=[],this.graphs=[],this.graphChangedCallback=function(){}}async queueAddFile(e,t){this.queue.push({name:t||e.name,content:new Promise((r,n)=>{e.arrayBuffer().then(s=>{s?r(s):n("empty file or directory")}).catch(s=>{n(s)})})})}async queueAddURL(e,t){const r=new URL(e);this.queue.push({name:t||e,content:new Promise((n,s)=>{fetch(r).then(o=>{o.status==200?o.arrayBuffer().then(a=>{n(a)}).catch(a=>{s(a)}):s(o.status.toString())}).catch(o=>{s(o)})})})}async queueRemove(e){this.queue.splice(e,1),this.csvImporter=void 0,this.csvImporterIndex=void 0}async queueLength(){return this.queue.length}async queueName(e){return this.queue[e].name}async queueSize(e){let t;try{t=await this.queue[e].content}catch{return null}return t.byteLength}async queueError(e){try{return await this.queue[e].content,null}catch(t){return t}}async csvParse(e){if(e!==this.csvImporterIndex){const t=await this.queue[e].content;this.csvImporter=new bi(t),this.csvImporterIndex=e}if(!this.csvImporter)throw new Error("Can't be here, csvImporter is undefined");return[this.csvImporter.header(),this.csvImporter.parseError(),this.csvImporter.numRows()]}async csvSlice(e,t,r){if(!this.csvImporter)throw new Error("Can't be here, csvImporter cannot be undefined");if(e!=this.csvImporterIndex)throw new Error("Can't be here, csvImporterIndex cannot be undefined");return this.csvImporter.slice(t,r)}async csvDetermine(e,t,r){var n;if(!this.csvImporter)throw new Error("Can't be here, csvImporter cannot be undefined");if(e!=this.csvImporterIndex)throw new Error("Can't be here, csvImporterIndex cannot be undefined");return(n=this.csvImporter)==null?void 0:n.determine(t,r)}async csvImport(e,t,r,n){if(!this.csvImporter)throw new Error("Can't be here, csvImporter cannot be undefined");if(e!=this.csvImporterIndex)throw new Error("Can't be here, csvImporterIndex cannot be undefined");const s=this.csvImporter.import(t,r,n);s.setAttribute("name",this.queue[e].name),this.graphs.push(s),this.graphChangedCallback()}async setGraphChangedCallback(e){this.graphChangedCallback=e}async numGraphs(){return this.graphs.length}async clientGraph(e){return{name:this.graphs[e].getAttribute("name"),order:this.graphs[e].order,size:this.graphs[e].size,directed:this.graphs[e].type=="directed"}}async removeGraph(e){this.graphs.splice(e,1),this.graphChangedCallback()}async degreeDistribution(e,t){if(e>=this.graphs.length)throw new Error(`Index ${e} is outside the bounds of array with length ${this.graphs.length}`);const r=this.graphs[e];if(t=="undirected"&&r.type!=="undirected")throw new Error(`Can't be here, graph must be undirected, got ${t}, graph is ${r.type}`);if((t=="in"||t=="out")&&r.type!=="directed")throw new Error("Can't be here, graph must be directed");const n=new Map;return this.graphs[e].forEachNode(s=>{let o=-1;if(t=="in")o=r.inDegree(s);else if(t=="out")o=r.outDegree(s);else if(t=="undirected")o=r.degree(s);else throw new Error("Can't be here, type must be one of in, out or undirected");n.has(o)||n.set(o,0),n.set(o,n.get(o)+1)}),n}}Ke(_i)})();
